<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Manual: Examples</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Manual
   &#160;<span id="projectnumber">0.1.0-doc-120</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('df/d1d/examples_page.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page contains <b>very basic</b> and <b>relatively short</b> examples demonstrating the usage of the principal functions of <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>.</p>
<p>The examples featured here are available in the directory <em>examples</em> of the repository. They are compiled along the library and their source code includes the description of their usage.</p>
<p>These examples where conceived with two goals in mind:</p><ul>
<li>Having examples for most of the functionnalities of <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em></li>
<li>Testing the implementation and efficiency of the implementation of a few methods</li>
</ul>
<p>In the examples you will learn how to create the objects representing the lattices and manipulate them, how to use the methods to manipulate those lattices basis, how to use the reduction algorithms available and how to compute basic mesures of interest like the spectral test and the normalized version of the spectral test.</p>
<p>Please note that the code presented here is in C++, meaning that much of it include statements, variable declarations and output formatting. The code segments relevant to the examples (that actually showcase <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a> fonctionnalities) have been commented to facilitate the code reading.</p>
<h3>Warning!</h3>
<p>It is not advised to run the <b>BasisConstruction</b> and the <b>Reduction</b> examples on a local machine because they use matrix sets that test their limits. Their execution takes a long time and uses a lot of memory. Users are nonetheless ecouraged to play with these examples, either by modifying them, or by generating another matrix set with the <code>python3</code> script in the <code>examples/bench.zip</code> archive.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000002">Todo:</a></b></dt><dd>Maybe the examples could only include the relevant parts of the code</dd></dl>
<h1><a class="anchor" id="sec_basis"></a>
Basis manipulation</h1>
<p>The following example showcases the usage of <code><a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html" title="This class implements general methods to perform a lattice basis construction from a set of vectors,...">LatticeTester::BasisConstruction</a></code>, either directly on matrices or on <code>IntLatticeBasis</code> objects. One of the repercutions this has is that this example also showcases how to create an <code>IntLatticeBasis</code> object.</p>
<p>This example compares the execution time of the two different methods for basis construction as well as the time taken to build a dual basis after one or the other. <code>BasisConstruction</code> contains two methods to build a basis from a set of generating vectors, <code>GCDConstruction</code> and <code>LLLConstruction</code>, described on the <code><a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html" title="This class implements general methods to perform a lattice basis construction from a set of vectors,...">LatticeTester::BasisConstruction</a></code> page. It is these methods that are compared here. Bellow is the code for the example.</p>
<div class="fragment"><div class="line"><span class="comment">// Defining constants for the execution of the algorithms</span></div><div class="line">BasisConstruction&lt;BScal&gt; constr; <span class="comment">// The basis constructor we will use</span></div><div class="line">BMat bas_mat, dua_mat; <span class="comment">// basis matrix and dual basis matrix</span></div><div class="line"><span class="comment">// Creating a lattice basis</span></div><div class="line">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt; lattice(bas_mat, numlines);</div><div class="line"><span class="comment">// Constructing a basis matrix with GCDConstruction</span></div><div class="line">constr.GCDConstruction(bas_mat);</div><div class="line"><span class="comment">// Constructing the matrix of a dual to bas_mat</span></div><div class="line">MScal modulo(1);</div><div class="line">constr.DualConstruction(bas_mat, dua_mat, modulo);</div><div class="line"><span class="comment">// Constructing a basis for lattice with LLLConstruction</span></div><div class="line">constr.LLLConstruction(lattice.getBasis());</div><div class="line">modulo = MScal(1);</div><div class="line">constr.DualConstruction(lattice.getBasis(), lattice.getDualBasis(), modulo);</div><div class="line"><span class="comment">// The preceding line works to compute a dual for lattice but does not set all</span></div><div class="line"><span class="comment">// the properties of lattice to properly work with a dual.</span></div><div class="line"><span class="comment">// This next line sets the lattice to know it has a dual. Computing the norm of</span></div><div class="line"><span class="comment">// the vectors in the lattice would also be wise.</span></div><div class="line">lattice.setDualFlag(<span class="keyword">true</span>);</div></div><!-- fragment --><p>There are two things to learn from this example. First is how to create an <code>IntLatticeBasis</code>. Second is the way that the <code>BasisConstruction</code> class is used.</p>
<p>When working only with <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code> it is recommended to represent lattices only by using the <code>IntLatticeBasis</code> class instead of the <code>IntLattice</code> class. The reasoning is that <code>IntLattice</code> does not bring any new functionnality by itself, it is a class that contains virtual methods specifying an easily expandable interface for different lattice types. It is also better to use <code>IntLatticeBasis</code> because the constructor is all that is needed to get a usable object as is done in this example. This is not the case of the <code>IntLattice</code> class.</p>
<p>Secondly, the <code>BasisConstruction</code> class is also very straight forward. Once the object is created, its methods can be called on matrices to transform them in place. Note that the usage of this class does not follow standard object oriented design. Since the algorithms in it are quite simple and are to be applied on basic types only, this constructed more like a container for those function, regrouping them in one simple location. Hence, when an object of this class is created, it is then possible to apply the contained algorithms on different objects as is done here.</p>
<p>The output of this program looks like this: </p><div class="fragment"><div class="line">               GCD    LLL     DUAL1    DUAL2</div><div class="line">Dim     5     4418   3074       735     1002</div><div class="line">Dim    10    13497   7900      2647     8151</div><div class="line">Dim    15    38502  20984      9543    19052</div><div class="line">Dim    20    94467  44949     88171    50834</div><div class="line">Dim    25   152712  86751    154730   181654</div><div class="line">Dim    30   594683 137168   2970433  1682890</div><div class="line">Dim    35 21994254 221505 168412442 13860037</div></div><!-- fragment --><h1><a class="anchor" id="sec_io"></a>
Using the input and output classes</h1>
<p>This is an example showing of the usage of both <code><a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html" title="Utility class that can be used to read different kind of data from a file.">LatticeTester::ParamReader</a></code> and <code><a class="el" href="../../d2/d30/classLatticeTester_1_1WriterRes.html" title="This class is a simple implementation of the Writer abstract class to write in plain text format on t...">LatticeTester::WriterRes</a></code>. These two classes can read from files and format output to them. Since this functionnality is the main way to make a program interractive, most uses that are not scripting will need these classes. Both classes can be created easily, simply by specifying a path for a file that <code>ParamReader</code> will read from and that <code>WriterRes</code> will write to. most methods are named quite explicitly as can be seen below.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define NTL_TYPES_CODE 1</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;latticetester/ParamReader.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/Types.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/Reducer.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/IntLatticeBasis.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/WriterRes.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;NTL/LLL.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keywordtype">int</span> size = 9;</div><div class="line">  <span class="comment">// Those two lines create a reader and ready it to be used.</span></div><div class="line">  <a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader&lt;MScal, BScal, RScal&gt;</a> reader(<span class="stringliteral">&quot;44matrixEx.dat&quot;</span>);</div><div class="line">  reader.getLines();</div><div class="line">  <span class="comment">// Reading a matrix as an examples</span></div><div class="line">  BMat matrix(size, size); <span class="comment">// The &quot;recipient&quot;</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ln = 0; <span class="comment">// The line counter</span></div><div class="line">  reader.readBMat(matrix, ln, 0, size);</div><div class="line"></div><div class="line">  <span class="comment">// Creation of a writer object for file IOExample.out</span></div><div class="line">  <a class="code" href="../../d2/d30/classLatticeTester_1_1WriterRes.html">WriterRes&lt;MScal&gt;</a> writer(<span class="stringliteral">&quot;IOExample.out&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Writing to the file</span></div><div class="line">  writer.writeString(<span class="stringliteral">&quot;We can write messages in the file.&quot;</span>);</div><div class="line">  writer.newLine();</div><div class="line">  writer.writeString(<span class="stringliteral">&quot;Here is one way to write a matrix.&quot;</span>);</div><div class="line">  writer.newLine();</div><div class="line">  writer.writeMMat(matrix);</div><div class="line"></div><div class="line">  <span class="comment">// Adding indentation</span></div><div class="line">  writer.beginTabbedSection();</div><div class="line">  writer.newLine();</div><div class="line">  writer.writeString(<span class="stringliteral">&quot;Here is another one.&quot;</span>);</div><div class="line">  writer.newLine();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; matrix.NumRows(); i++) {</div><div class="line">    writer.writeString(<span class="stringliteral">&quot;[&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; matrix.NumCols(); j++) {</div><div class="line">      writer.writeIntScal(matrix[i][j]);</div><div class="line">      <span class="keywordflow">if</span> (j == matrix.NumCols()-1) <span class="keywordflow">continue</span>;</div><div class="line">      writer.writeString(<span class="stringliteral">&quot; &quot;</span>);</div><div class="line">    }</div><div class="line">    writer.writeString(<span class="stringliteral">&quot;]&quot;</span>);</div><div class="line">    writer.newLine();</div><div class="line">  }</div><div class="line">  <span class="comment">// Printing \n and ending indented section.</span></div><div class="line">  writer.newParagraph();</div><div class="line"></div><div class="line">  writer.writeString(<span class="stringliteral">&quot;It&#39;s also possible to use *ToString() methods to write&quot;</span></div><div class="line">      <span class="stringliteral">&quot; stuff in the output\nfile.&quot;</span>);</div><div class="line">  writer.newLine();</div><div class="line">  <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a> lat_basis(matrix, size);</div><div class="line">  lat_basis.updateVecNorm();</div><div class="line">  lat_basis.sort(0);</div><div class="line">  <span class="comment">// Writing in the file</span></div><div class="line">  writer.writeString(<span class="stringliteral">&quot;The matrix and its vectors norms:&quot;</span>);</div><div class="line">  writer.newLine();</div><div class="line">  writer.writeString(lat_basis.toStringBasis());</div><div class="line">  writer.newLine();</div><div class="line"></div><div class="line">  writer.writeString(<span class="stringliteral">&quot;Writers can be used as the program progresses, just like&quot;</span></div><div class="line">      <span class="stringliteral">&quot;using a standard\noutput print, but also can be created at the end of the&quot;</span></div><div class="line">      <span class="stringliteral">&quot;execution to print the\nresult of the execution, making them quite&quot;</span></div><div class="line">      <span class="stringliteral">&quot;flexible.&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The way that the reader class works, is that you call a method such as <code>readBMat</code> in the example and it will store the requested type in a container specified as the first argument. It reads on a line specified as the second argument (starting from 0) and reads starting from the n-th word of that line (n being specified as a third argument, starting from 0). If a fourth argument is needed, it is type specific like here where the matrix needs a dimension.</p>
<p>The writer class works the same, but is a little simpler since everything is written sequentially. This class can also (try to) enforce indentation of the ouputed text. To do that, the usage of the <code>newLine</code> method, as is done in this example, is needed. This example is fairly limited in scope and does not contain other other information relevant to the usage of <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code>.</p>
<h1><a class="anchor" id="sec_reduc"></a>
The Reducer class</h1>
<p>This following example is about the usage of the <code><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html" title="This class implements (or wraps from NTL) all the functions that are needed to reduce a basis.">LatticeTester::Reducer</a></code> class. This class is central to <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> and contains the most important features of the library. This example uses most of the functions of that class and tries to compare their execution times. This example works very similarly to the <code>BasisConstruction</code> example.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// We define the numeric types.</span></div><div class="line"><span class="comment">// It is possible to use this example with TYPES 2 and 3. For now 1 calls the</span></div><div class="line"><span class="comment">// same function for both execution and we look forward to change that.</span></div><div class="line"><span class="preprocessor">#define NTL_TYPES_CODE 2</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ctime&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;latticetester/ParamReader.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/Types.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/Reducer.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/IntLatticeBasis.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/WriterRes.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;Examples.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>{</div><div class="line">  <span class="comment">// Returns the average of the length of this vector</span></div><div class="line">  NScal average(NVect vector) {</div><div class="line">    NScal sum(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;vector.length(); i++) {</div><div class="line">      sum += vector[i];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> sum/NScal(vector.length());</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  clock_t timer = clock();</div><div class="line">  <span class="keywordtype">int</span> max_dim = 10; </div><div class="line">  clock_t die_time[max_dim], lll_time[max_dim], bkz_time[max_dim],</div><div class="line">  sho_die[max_dim], sho_lll[max_dim], sho_bkz[max_dim], tmp;</div><div class="line">  clock_t total_times[6];</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; max_dim; i++){</div><div class="line">    lll_time[i] = 0;</div><div class="line">    die_time[i] = 0;</div><div class="line">    bkz_time[i] = 0;</div><div class="line">    sho_die[i] = 0;</div><div class="line">    sho_lll[i] = 0;</div><div class="line">    sho_bkz[i] = 0;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> die_fails=0, lll_fails=0, bkz_fails=0;</div><div class="line">  NScal vec_length[3];</div><div class="line">  vec_length[0] = vec_length[1] = vec_length[2] = 0;</div><div class="line"></div><div class="line">  std::string prime = primes[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; max_dim; j++) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 10; k++) {</div><div class="line">      <span class="comment">// We dynamically allocate memory to these two pointers every time we need to</span></div><div class="line">      <span class="comment">// create an object of their type. This is because of the OOP approach</span></div><div class="line">      <span class="comment">// to lattice reduction.</span></div><div class="line">      <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a>* basis;</div><div class="line">      <a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer&lt;MScal, BScal, NScal, RScal&gt;</a>* red;</div><div class="line"></div><div class="line">      <a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader&lt;MScal, BScal, RScal&gt;</a> reader;</div><div class="line">      std::string name;</div><div class="line">      <span class="keywordtype">int</span> numlines;</div><div class="line">      BMat matrix1;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ln;</div><div class="line"></div><div class="line">      name = <span class="stringliteral">&quot;bench/&quot;</span> + prime + <span class="stringliteral">&quot;_&quot;</span> + std::to_string(5*(j+1)) + <span class="stringliteral">&quot;_&quot;</span> + std::to_string(k);</div><div class="line">      reader = <a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader&lt;MScal, BScal, RScal&gt;</a>(name + <span class="stringliteral">&quot;.dat&quot;</span>);</div><div class="line">      reader.<a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a819fed133f35078ba1ccc8e039228ed9">getLines</a>();</div><div class="line">      reader.<a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a6171b6f5ac9550a97688b44bdbdfe592">readInt</a>(numlines, 0, 0);</div><div class="line">      matrix1.SetDims(numlines, numlines);</div><div class="line">      ln = 1;</div><div class="line">      reader.<a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html#aa0e31770edbb6ecfb48e80231ed5c1ce">readBMat</a>(matrix1, ln, 0, numlines);</div><div class="line"></div><div class="line">      <span class="comment">// Dieter reduction before shortest vector search</span></div><div class="line">      tmp = clock();</div><div class="line">      basis = <span class="keyword">new</span> <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a>(matrix1, numlines);</div><div class="line">      red = <span class="keyword">new</span> <a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer&lt;MScal, BScal, NScal, RScal&gt;</a>(*basis);</div><div class="line">      red-&gt;<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a05fb2731f7bd7b3672424ae81f995270">redDieter</a>(0);</div><div class="line">      die_time[j] += clock() - tmp;</div><div class="line">      basis-&gt;<a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#ae3130ab54d36671618cf3f44a807f530">updateVecNorm</a>();</div><div class="line">      vec_length[0] += average(basis-&gt;<a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a878fedc00d47a1717c84f8db2674dddf">getVecNorm</a>());</div><div class="line">      tmp = clock();</div><div class="line">      <span class="keywordflow">if</span> (!red-&gt;<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6b907a63eadf3cda2839a3865883e68f">shortestVector</a>(L2NORM)) {</div><div class="line">        die_fails++;</div><div class="line">      }</div><div class="line">      sho_die[j] += clock() - tmp;</div><div class="line">      <span class="keyword">delete</span> red;</div><div class="line">      <span class="comment">//std::cout &lt;&lt; &quot;Dieter: &quot; &lt;&lt; average(basis-&gt;getVecNorm()) &lt;&lt; &quot;\n&quot;;</span></div><div class="line">      <span class="keyword">delete</span> basis;</div><div class="line"></div><div class="line">      <span class="comment">// LLL reduction before shortest vector search</span></div><div class="line">      tmp = clock();</div><div class="line">      basis = <span class="keyword">new</span> <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a>(matrix1, numlines);</div><div class="line">      red = <span class="keyword">new</span> <a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer&lt;MScal, BScal, NScal, RScal&gt;</a>(*basis);</div><div class="line">      red-&gt;<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a9c0792ad9a42d12dd69248c0e20b4544">redLLLNTL</a>();</div><div class="line">      lll_time[j] += clock() - tmp;</div><div class="line">      basis-&gt;<a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#ae3130ab54d36671618cf3f44a807f530">updateVecNorm</a>();</div><div class="line">      vec_length[1] += average(basis-&gt;<a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a878fedc00d47a1717c84f8db2674dddf">getVecNorm</a>());</div><div class="line">      tmp = clock();</div><div class="line">      <span class="keywordflow">if</span> (!red-&gt;<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6b907a63eadf3cda2839a3865883e68f">shortestVector</a>(L2NORM)) {</div><div class="line">        lll_fails++;</div><div class="line">      }</div><div class="line">      sho_lll[j] += clock() - tmp;</div><div class="line">      <span class="keyword">delete</span> red;</div><div class="line">      <span class="comment">//std::cout &lt;&lt; &quot;LLL: &quot; &lt;&lt; average(basis-&gt;getVecNorm()) &lt;&lt; &quot;\n&quot;;</span></div><div class="line">      <span class="keyword">delete</span> basis;</div><div class="line"></div><div class="line">      <span class="comment">// BKZ reduction before shortest vector search</span></div><div class="line">      tmp = clock();</div><div class="line">      basis = <span class="keyword">new</span> <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a>(matrix1, numlines);</div><div class="line">      red = <span class="keyword">new</span> <a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer&lt;MScal, BScal, NScal, RScal&gt;</a>(*basis);</div><div class="line">      red-&gt;<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ad3976273ae6a66d009ac9a14625d016c">redBKZ</a>();</div><div class="line">      bkz_time[j] += clock() - tmp;</div><div class="line">      basis-&gt;<a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#ae3130ab54d36671618cf3f44a807f530">updateVecNorm</a>();</div><div class="line">      vec_length[2] += average(basis-&gt;<a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a878fedc00d47a1717c84f8db2674dddf">getVecNorm</a>());</div><div class="line">      tmp = clock();</div><div class="line">      <span class="keywordflow">if</span> (!red-&gt;<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6b907a63eadf3cda2839a3865883e68f">shortestVector</a>(L2NORM)) {</div><div class="line">        bkz_fails++;</div><div class="line">      }</div><div class="line">      sho_bkz[j] += clock() - tmp;</div><div class="line">      <span class="keyword">delete</span> red;</div><div class="line">      <span class="comment">//std::cout &lt;&lt; &quot;BKZ: &quot; &lt;&lt; average(basis-&gt;getVecNorm()) &lt;&lt; &quot;\n&quot;;</span></div><div class="line">      <span class="keyword">delete</span> basis;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;ALL THE RESULTS ARE NUMBERED IN TERMS OF SYSTEM CLOCK TICKS\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;          &quot;</span>;</div><div class="line">  <span class="keywordtype">int</span> width1 = getWidth(die_time, max_dim, <span class="stringliteral">&quot;Dieter&quot;</span>, total_times, 0);</div><div class="line">  <span class="keywordtype">int</span> width2 = getWidth(lll_time, max_dim, <span class="stringliteral">&quot;LLL&quot;</span>, total_times, 1);</div><div class="line">  <span class="keywordtype">int</span> width3 = getWidth(bkz_time, max_dim, <span class="stringliteral">&quot;BKZ&quot;</span>, total_times, 2);</div><div class="line">  <span class="keywordtype">int</span> width4 = getWidth(sho_die, max_dim, <span class="stringliteral">&quot;SV Dieter&quot;</span>, total_times, 3);</div><div class="line">  <span class="keywordtype">int</span> width5 = getWidth(sho_lll, max_dim, <span class="stringliteral">&quot;SV LLL&quot;</span>, total_times, 4);</div><div class="line">  <span class="keywordtype">int</span> width6 = getWidth(sho_bkz, max_dim, <span class="stringliteral">&quot;SV BKZ&quot;</span>, total_times, 5);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Total time&quot;</span> &lt;&lt; std::setw(width1) &lt;&lt; total_times[0]</div><div class="line">    &lt;&lt; std::setw(width2) &lt;&lt; total_times[1]</div><div class="line">    &lt;&lt; std::setw(width3) &lt;&lt; total_times[2]</div><div class="line">    &lt;&lt; std::setw(width4) &lt;&lt; total_times[3]</div><div class="line">    &lt;&lt; std::setw(width5) &lt;&lt; total_times[4]</div><div class="line">    &lt;&lt; std::setw(width6) &lt;&lt; total_times[5] &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; max_dim; i++) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Dim &quot;</span> &lt;&lt; std::setw(6) &lt;&lt; (i+1)*5 </div><div class="line">      &lt;&lt; std::setw(width1) &lt;&lt; die_time[i] </div><div class="line">      &lt;&lt; std::setw(width2) &lt;&lt; lll_time[i] </div><div class="line">      &lt;&lt; std::setw(width3) &lt;&lt; bkz_time[i] </div><div class="line">      &lt;&lt; std::setw(width4) &lt;&lt; sho_die[i] </div><div class="line">      &lt;&lt; std::setw(width5) &lt;&lt; sho_lll[i] </div><div class="line">      &lt;&lt; std::setw(width6) &lt;&lt; sho_bkz[i] </div><div class="line">      &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Fails     &quot;</span></div><div class="line">    &lt;&lt; std::setw(width1) &lt;&lt; die_fails </div><div class="line">    &lt;&lt; std::setw(width2) &lt;&lt; lll_fails </div><div class="line">    &lt;&lt; std::setw(width3) &lt;&lt; bkz_fails </div><div class="line">    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; <span class="stringliteral">&quot;Averages: &quot;</span> &lt;&lt; std::setw(width1) &lt;&lt; vec_length[0]/vec_length[1]</div><div class="line">    &lt;&lt; std::setw(width2) &lt;&lt; 1.0 &lt;&lt; std::setw(width3) &lt;&lt; vec_length[2]/vec_length[1]</div><div class="line">    &lt;&lt;std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Total time: &quot;</span> &lt;&lt; (double)(clock()-timer)/(CLOCKS_PER_SEC*60) &lt;&lt; <span class="stringliteral">&quot; minutes\n&quot;</span>;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This example first showcases the usage of the <code>Reducer</code> class. This class is one that is given a <code><a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html" title="This class represents a lattice and its basis and offers tools to do basic manipulations on lattice b...">LatticeTester::IntLatticeBasis</a></code> and then performs various algorithms on it when its methods are called. The methods this class implements perform what we call "reductions". Reductions are algorithms that reduce, in one way or another, the length of the vectors in the basis stored in the <code>IntLatticeBasis</code>. This example calls most of them, and the code bellow links to the documentation of these methods.</p>
<p>The program tests three reductions (Dieter, LLL and BKZ) in two ways. First, it performs it and times the execution of the reduction algorithm itself. this is what is shown in the first 3 columns of the results. The program then perform the "Shortest Vector" reduction, which is the search for the shortest non-zero vector in the lattice (see <a class="el" href="../../da/d18/a_intro.html">Background</a>). This search is particularly costly so reducing the lattice basis first usually gains time. The next 3 colums show the execution times for the shortest vector reduction depending on the reduction algorithm used first. Finally, the example also records the number of failures of the shortest vector search for each algorithms. Below is an example output for this example.</p>
<div class="fragment"><div class="line">ALL THE RESULTS ARE NUMBERED IN TERMS OF SYSTEM CLOCK TICKS</div><div class="line">            Dieter    LLL     BKZ   SV Dieter     SV LLL     SV BKZ</div><div class="line">Total time 7479736 804050 2414321 11960009667 2665878917 2444318476</div><div class="line">Dim      5    3889    873     945         634        583        579</div><div class="line">Dim     10   25622   3104    4025        3012       2603       2582</div><div class="line">Dim     15   52247   6485   10449        8268       6081       6023</div><div class="line">Dim     20   94343  12015   23153       20410      12513      12014</div><div class="line">Dim     25  137098  22926   48952      262480      36137      29878</div><div class="line">Dim     30  195888  30963   87739      604659     141528     105142</div><div class="line">Dim     35  350096  44862  149397     9703739    1469959     968583</div><div class="line">Dim     40  468672  54571  176943    28913921    5581257    3571159</div><div class="line">Dim     45  619861  80332  229724   607680675   66124526   53250411</div><div class="line">Dim     50  839252  98698  269042  1260636786  110130393  102112537</div><div class="line">Dim     55 1119413 125894  364620  2351365585  186791907  204776212</div><div class="line">Dim     60 1591436 120304  420965  3423588351  416827286  371013095</div><div class="line">Dim     65 1981919 203023  628367  4277221147 1878754144 1708470261</div><div class="line">Fails           14      2       2</div><div class="line">Total time: 284.743 minutes</div></div><!-- fragment --><h1><a class="anchor" id="sec_FOM"></a>
Construction figures of merit</h1>
<p>This examples shows how it is possible to use <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> to compute a variety of figures of merit. This example uses a few different tools that have not been presented before: <code><a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html" title="This class implements general methods to perform a lattice basis construction from a set of vectors,...">LatticeTester::BasisConstruction</a></code> as a way to build projections of a lattice, <code><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html" title="A namespace containing different implementation of sets of coordinates.">LatticeTester::CoordinateSets</a></code>, a namespace containing classes to create indices sets and <code><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html" title="Abstract class representing Weights for figures of merit.">LatticeTester::Weights</a></code> and its subclasses that ease the weighting of different projections in a figure of merit.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define NTL_TYPES_CODE 2</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;latticetester/Types.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/IntLatticeBasis.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/Reducer.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/ParamReader.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Application specific headers</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/NormaBestLat.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/NormaBestBound.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/CoordinateSets.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/UniformWeights.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;latticetester/BasisConstruction.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keywordtype">int</span> min_dim = 0, max_dim = 10;</div><div class="line">  <a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader&lt;MScal, BScal, RScal&gt;</a> reader(<span class="stringliteral">&quot;./44matrixEx.dat&quot;</span>);</div><div class="line">  reader.<a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a819fed133f35078ba1ccc8e039228ed9">getLines</a>();</div><div class="line">  BMat matrix(max_dim,max_dim);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ln = 0;</div><div class="line">  reader.<a class="code" href="../../da/d47/classLatticeTester_1_1ParamReader.html#aa0e31770edbb6ecfb48e80231ed5c1ce">readBMat</a>(matrix, ln, 0, max_dim);</div><div class="line">  <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a> lat_basis(matrix, max_dim);</div><div class="line">  <span class="keywordtype">double</span> merit1 = 1.0, merit2 = 1.0;</div><div class="line"></div><div class="line">  <span class="comment">// The variables specific to the construction of a figure of merit</span></div><div class="line">  <a class="code" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html">UniformWeights</a> weights(1.0); <span class="comment">// This just puts a weight of 1 to everything</span></div><div class="line">  <a class="code" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html">BasisConstruction&lt;BScal&gt;</a> constructor; <span class="comment">// Computes projections basis</span></div><div class="line">  <a class="code" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis&lt;MScal, BScal, NScal, RScal&gt;</a> proj_basis(max_dim); <span class="comment">// To store projections</span></div><div class="line">  <span class="comment">// CoordinateSets namespace contains classes to create iterators on sets of coordinates</span></div><div class="line">  <a class="code" href="../../d8/d34/classLatticeTester_1_1CoordinateSets_1_1FromRanges.html">CoordinateSets::FromRanges</a> coord(min_dim+1, max_dim, min_dim, max_dim-1);</div><div class="line"></div><div class="line">  <span class="comment">// For loop on the iterator built previously</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = coord.begin(); it != coord.end(); it++){</div><div class="line">    <span class="comment">// Computing the projection</span></div><div class="line">    constructor.<a class="code" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#a32a4a2a2e8e85c616c45fdecbb4d6b72">ProjectionConstruction</a>(lat_basis, proj_basis, *it);</div><div class="line"></div><div class="line">    proj_basis.updateVecNorm();</div><div class="line">    proj_basis.sort(0);</div><div class="line">    <a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer&lt;MScal, BScal, NScal, RScal&gt;</a> red(proj_basis);</div><div class="line">    red.<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ad3976273ae6a66d009ac9a14625d016c">redBKZ</a>();</div><div class="line">    red.<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6b907a63eadf3cda2839a3865883e68f">shortestVector</a>(L2NORM);</div><div class="line">    <span class="keywordtype">double</span> shortest = NTL::conv&lt;double&gt;(red.<a class="code" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aabb5c4adb586ba0a805ab0a570ba7cee">getMinLength</a>());</div><div class="line"></div><div class="line">    <span class="comment">// Instanciating the normalizers</span></div><div class="line">    <span class="comment">// The prefered way of doing this is descibed in Normalizer documentation</span></div><div class="line">    RScal log_density=-log(<a class="code" href="../../d8/d74/namespaceLatticeTester.html#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs</a>(NTL::determinant(proj_basis.getBasis())));</div><div class="line">    <a class="code" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer&lt;RScal&gt;</a>* norma = <span class="keyword">new</span> <a class="code" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat&lt;RScal&gt;</a>(log_density, max_dim);</div><div class="line"></div><div class="line">    <span class="comment">// Computing the figure of merit for this projection</span></div><div class="line">    <span class="keywordtype">double</span> merit = weights.getWeight(*it) * shortest/norma-&gt;getBound((*it).size());</div><div class="line">    <span class="comment">// Testing if it is the minimum as of now</span></div><div class="line">    <span class="keywordflow">if</span> (merit &lt; merit1) merit1 = merit;</div><div class="line">    <span class="keyword">delete</span> norma;</div><div class="line">    norma = <span class="keyword">new</span> <a class="code" href="../../df/de5/classLatticeTester_1_1NormaBestBound.html">NormaBestBound&lt;RScal&gt;</a>(log_density, max_dim);</div><div class="line">    merit = weights.getWeight(*it) * shortest/norma-&gt;getBound((*it).size());</div><div class="line">    <span class="keywordflow">if</span> (merit &lt; merit2) merit2 = merit;</div><div class="line">    <span class="keyword">delete</span> norma;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Figure of merit with BestLat: &quot;</span> &lt;&lt; merit1 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Figure of merit with BestBound: &quot;</span> &lt;&lt; merit2 &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Figures of merit are different for different normalizers,&quot;</span></div><div class="line">    <span class="stringliteral">&quot; weights and projections choices\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note that this example is fairly short, which stands out from the other examples, but also from what we would expect from a typical <code>C++</code> program. Only a few more lines would be needed to make this program read a file name from the command line to perform the computation of the same figure of merit on different matrices.</p>
<p>The first new class seen here is <code><a class="el" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html" title="This class is used to implement the same weight for all projections.">LatticeTester::UniformWeights</a></code>. This is one of the few classes that inherit from the <code>Weights</code> class stated before. The base class only specifies an interface and the subclasses <code><a class="el" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html" title="This class is used to implement the same weight for all projections.">LatticeTester::UniformWeights</a></code>, <code><a class="el" href="../../da/d3e/classLatticeTester_1_1ProductWeights.html" title="Product weights.">LatticeTester::ProductWeights</a></code>, <code><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html" title="Projection-dependent weights.">LatticeTester::ProjectionDependentWeights</a></code> and <code><a class="el" href="../../d4/de7/classLatticeTester_1_1PODWeights.html" title="Product and order-dependent (POD) weights.">LatticeTester::PODWeights</a></code> are implementations of weighting classes. These classes are classes that can assign different weights to different projections of a lattice when computing a figure of merit. Typically, these weights only have to be multiplied to the value computed for a projection by specifying the projection to the object. In the case of this example, uniform weights of value 1 are used. This multiplies 1 to every figure of merit, which does nothing. But using other more sophisticated weights would only change the construction process for them and not the actual usage.</p>
<p>The next new thing going on is the usage of the <code>ProjectionConstruction</code> method of the <code>BasisConstruction</code> class. This method is aptly named, as it simply constructs a projection, specified by the third argument, from the first lattice argument and puts it into the second lattice argument. To use this method, it is recommended to pair it with one of the <code>CoordinateSets</code>. These class can be modified to generate coordinate subsets from a list of coordinates, generally the lattice coordinates. From instances of these classes, it is possible to obtain an iterator to perform a loop over the coordinates sets as is done in the example.</p>
<p>The last thing going on is the usage of some <code>Normalizer</code> classes. <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code> contains a few classes implementing a normalizer. They are all subclasses of the <code>Normalizer</code> class and can all be instanciated as specified in the documentation of that class. To use this class, it suffices to divide the length of the shortest vector in the lattice by the bound in the dimension of that vector obtained with <code>getBound(dim)</code>. If the normalizer has correctly been instanciated, the obtained number should be a mesure rescalled between 0 and 1. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">LatticeTester Manual</a></li>
    <li class="footer">Generated on Mon Jun 3 2019 17:37:00 for Lattice Tester Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
