<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Manual: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Manual
   &#160;<span id="projectnumber">0.1.0-work-43</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LatticeTester Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lattice namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace containing different implementation of sets of coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html">BasisConstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>WARNING</b> THIS MODULE IS UNDER CONSTRUCTION.  <a href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a <code>std::set&lt;std::size_t&gt;</code>.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d95/classLatticeTester_1_1IntFactor.html">IntFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects of this class are the "prime" factors in the decomposition of a positive integer.  <a href="../../d6/d95/classLatticeTester_1_1IntFactor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a skeleton for the implementation of different types of lattices of arbitrary rank.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a lattice and its basis and offers tools to do basic manipulations on lattice bases.  <a href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html">Lacunary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a set of indices with lacunary values.  <a href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html">LatticeAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects of this class can perform various tests on lattices.  <a href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to save the configuration of a lattice test.  <a href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de5/classLatticeTester_1_1NormaBestBound.html">NormaBestBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current implementation does not implement the bounds for now  <a href="../../df/de5/classLatticeTester_1_1NormaBestBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes which inherit from this base class are used in implementing bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html">NormaMinkL1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in space.  <a href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html">NormaMinkowski</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <code>Palpha</code>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html">OrderDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order-dependent weights.  <a href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that can be used to read different kind of data from a file.  <a href="../../da/d47/classLatticeTester_1_1ParamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de7/classLatticeTester_1_1PODWeights.html">PODWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product and order-dependent (POD) weights.  <a href="../../d4/de7/classLatticeTester_1_1PODWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3e/classLatticeTester_1_1ProductWeights.html">ProductWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product weights.  <a href="../../da/d3e/classLatticeTester_1_1ProductWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection-dependent weights.  <a href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9a/classLatticeTester_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates random numbers (in fact pseudo-random numbers).  <a href="../../dc/d9a/classLatticeTester_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a general rank 1 lattice.  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements (or wraps from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>) all the functions that are needed to reduce a basis.  <a href="../../d8/de3/classLatticeTester_1_1Reducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df9/classLatticeTester_1_1Types.html">Types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets standard <code>typedef</code>’s for the types that can be used in <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace. ">LatticeTester</a>.  <a href="../../d6/df9/classLatticeTester_1_1Types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html">UniformWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement the same weight for all projections.  <a href="../../d7/d89/classLatticeTester_1_1UniformWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class representing <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html" title="Abstract class representing Weights for figures of merit. ">Weights</a> for figures of merit.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html">Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract class that represents an interface to <code><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html" title="This is an abstract class that represents an interface to Writer classes. ">Writer</a></code> classes.  <a href="../../d4/dc5/classLatticeTester_1_1Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d30/classLatticeTester_1_1WriterRes.html">WriterRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple implementation of the <code><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html" title="This is an abstract class that represents an interface to Writer classes. ">Writer</a></code> abstract class to write in plain text format on the stream.  <a href="../../d2/d30/classLatticeTester_1_1WriterRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> <tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which norm is used to measure the length of vectors.  <a href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f099c800f4c648134967a45b91058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a> <tr class="memdesc:ad78f099c800f4c648134967a45b91058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which form and where the results will be sent.  <a href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad78f099c800f4c648134967a45b91058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> <tr class="memdesc:a94f96ff406f8b56147a2b7fd96209cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which precision the <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> algorithms will be perfoms : <code>FP</code> &ndash; double <code>QP</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XD</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point) this is useful for large precision and magnitudes Generally speaking, the choice FP will be the fastest, but may be prone to roundoff errors and/or overflow.  <a href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64954fb374b16e1fe991e435501d65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> <tr class="memdesc:a9b64954fb374b16e1fe991e435501d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don’t care).  <a href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9b64954fb374b16e1fe991e435501d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> <tr class="memdesc:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the merit criterion for ranking generators or lattices.  <a href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> <tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\).  <a href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> <tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191af830e61af769e233e1b03138520e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> <tr class="memdesc:a191af830e61af769e233e1b03138520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the Prereduction Type (BKZ, LenstraLL, ...) used before applying the Branch and Bound procedure.  <a href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a191af830e61af769e233e1b03138520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61a624270d67110531f2dea4c739eff5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a61a624270d67110531f2dea4c739eff5">lFactorial</a> (int t)</td></tr>
<tr class="memdesc:a61a624270d67110531f2dea4c739eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <a href="#a61a624270d67110531f2dea4c739eff5">More...</a><br /></td></tr>
<tr class="separator:a61a624270d67110531f2dea4c739eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a886c94b54767104cea58e0f1b6c0d11e">Digamma</a> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\).  <a href="#a886c94b54767104cea58e0f1b6c0d11e">More...</a><br /></td></tr>
<tr class="separator:a886c94b54767104cea58e0f1b6c0d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e699673c28800e0563b14a05392d1c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7e699673c28800e0563b14a05392d1c0">BernoulliPoly</a> (int n, double x)</td></tr>
<tr class="memdesc:a7e699673c28800e0563b14a05392d1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <a href="#a7e699673c28800e0563b14a05392d1c0">More...</a><br /></td></tr>
<tr class="separator:a7e699673c28800e0563b14a05392d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a61a4b5013c295f9f07b9b2d8f26ee5f4">Harmonic</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n = \sum_{j=1}^n 1/j\).  <a href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">More...</a><br /></td></tr>
<tr class="separator:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum </p><p class="formulaDsp">
\[ \sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum.  <a href="#a3aefa49a034495dcc46721c275f329b0">More...</a><br /></td></tr>
<tr class="separator:a3aefa49a034495dcc46721c275f329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vJOE92b">[11]</a>) </p><p class="formulaDsp">
\[ S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}. \]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\).  <a href="#a0bb56e7569fb24800973df89d757f2fd">More...</a><br /></td></tr>
<tr class="separator:a0bb56e7569fb24800973df89d757f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes.  <a href="#ab5f708fa0e8d6aa53427b3e8927f5504">More...</a><br /></td></tr>
<tr class="separator:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5744c76f19028a3bd469d318108dd5e"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasIntMat &gt; </td></tr>
<tr class="memitem:ae5744c76f19028a3bd469d318108dd5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae5744c76f19028a3bd469d318108dd5e">initNorm</a> (<a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a>&lt; Int, BasIntMat &gt; &amp;config)</td></tr>
<tr class="memdesc:ae5744c76f19028a3bd469d318108dd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the norm in config depending on it's normalizer.  <a href="#ae5744c76f19028a3bd469d318108dd5e">More...</a><br /></td></tr>
<tr class="separator:ae5744c76f19028a3bd469d318108dd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes references to two variables of a generic type and swaps their content.  <a href="#ad4d16fed8fda92252dc423db28136932">More...</a><br /></td></tr>
<tr class="separator:ad4d16fed8fda92252dc423db28136932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42956b9be5474c04704701d5aba906cc"><td class="memTemplParams" colspan="2">template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:a42956b9be5474c04704701d5aba906cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a42956b9be5474c04704701d5aba906cc">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a42956b9be5474c04704701d5aba906cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">}.  <a href="#a42956b9be5474c04704701d5aba906cc">More...</a><br /></td></tr>
<tr class="separator:a42956b9be5474c04704701d5aba906cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf71d740b6bd3ef605406a4493939692"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:abf71d740b6bd3ef605406a4493939692"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abf71d740b6bd3ef605406a4493939692">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:abf71d740b6bd3ef605406a4493939692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#abf71d740b6bd3ef605406a4493939692">More...</a><br /></td></tr>
<tr class="separator:abf71d740b6bd3ef605406a4493939692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0f1e552bdaa65b87d6fd17c57edb040e">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#a0f1e552bdaa65b87d6fd17c57edb040e">More...</a><br /></td></tr>
<tr class="separator:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8412cabdb8630ae40926d3257dddb2"><td class="memTemplParams" colspan="2">template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a8a8412cabdb8630ae40926d3257dddb2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8a8412cabdb8630ae40926d3257dddb2">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a8a8412cabdb8630ae40926d3257dddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">}.  <a href="#a8a8412cabdb8630ae40926d3257dddb2">More...</a><br /></td></tr>
<tr class="separator:a8a8412cabdb8630ae40926d3257dddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">toString functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Useful functions for printing the <code>enum</code> constants in this module.</p>
<p>Returns the <code>enum</code> constants in this module as strings. </p>
</div></td></tr>
<tr class="memitem:a008a0f13f3dd13f786385093e6bff477"><td class="memItemLeft" align="right" valign="top"><a id="a008a0f13f3dd13f786385093e6bff477"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorm</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>)</td></tr>
<tr class="separator:a008a0f13f3dd13f786385093e6bff477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822e2af752a071d540ed96e8b5919ed"><td class="memItemLeft" align="right" valign="top"><a id="a9822e2af752a071d540ed96e8b5919ed"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrime</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a>)</td></tr>
<tr class="separator:a9822e2af752a071d540ed96e8b5919ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce69d86ac936dd6fc557c0dfa57a39b"><td class="memItemLeft" align="right" valign="top"><a id="a7ce69d86ac936dd6fc557c0dfa57a39b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCriterion</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a>)</td></tr>
<tr class="separator:a7ce69d86ac936dd6fc557c0dfa57a39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9d3e6f7b852580034df6ba3e2eed5"><td class="memItemLeft" align="right" valign="top"><a id="a8ed9d3e6f7b852580034df6ba3e2eed5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorma</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>)</td></tr>
<tr class="separator:a8ed9d3e6f7b852580034df6ba3e2eed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ef31cf1e22bf8f4bba3f46bf74435f"><td class="memItemLeft" align="right" valign="top"><a id="ae8ef31cf1e22bf8f4bba3f46bf74435f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCalc</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a>)</td></tr>
<tr class="separator:ae8ef31cf1e22bf8f4bba3f46bf74435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58006e68111d503cf4096bf9ffc9546"><td class="memItemLeft" align="right" valign="top"><a id="ae58006e68111d503cf4096bf9ffc9546"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPreRed</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>)</td></tr>
<tr class="separator:ae58006e68111d503cf4096bf9ffc9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfcce9fb68f4fe2a1fd58f164ed3bbf"><td class="memItemLeft" align="right" valign="top"><a id="aabfcce9fb68f4fe2a1fd58f164ed3bbf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringOutput</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a>)</td></tr>
<tr class="separator:aabfcce9fb68f4fe2a1fd58f164ed3bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139260fd72d3392ffac14fede81a693d"><td class="memItemLeft" align="right" valign="top"><a id="a139260fd72d3392ffac14fede81a693d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrecision</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>)</td></tr>
<tr class="separator:a139260fd72d3392ffac14fede81a693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All the functions of this module use LFSR258 as an underlying source for pseudo-random numbers.</p>
<p>A free (as in freedom) implementation of this generator can be found at <a href="http://simul.iro.umontreal.ca/">http://simul.iro.umontreal.ca/</a> as well as the article presenting it. All the functions generating some sort of random number will advance an integer version of LFSR258 by one state and output a transformation of the state to give a double, an int or bits. </p>
</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <a href="#abba336d3a5abb22b8367ddfa37a713e4">More...</a><br /></td></tr>
<tr class="separator:abba336d3a5abb22b8367ddfa37a713e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8e829d77e42c8dbabc8f6e37eca2a714">RandInt</a> (int i, int j)</td></tr>
<tr class="memdesc:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform pseudo-random integer in \([i, j]\).  <a href="#a8e829d77e42c8dbabc8f6e37eca2a714">More...</a><br /></td></tr>
<tr class="separator:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a56b8827c239bd1293eacd356e5cbe3b2">RandBits</a> (int s)</td></tr>
<tr class="memdesc:a56b8827c239bd1293eacd356e5cbe3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer.  <a href="#a56b8827c239bd1293eacd356e5cbe3b2">More...</a><br /></td></tr>
<tr class="separator:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <a href="#a1a68bc6b1e81a03d09ea07fa9efed658">More...</a><br /></td></tr>
<tr class="separator:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are basic wrapper and overloads to common mathematical functions such as logarithm, exponentiation, and square-root. </p>
</div></td></tr>
<tr class="memitem:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa1b3094c46a9f69a9f1bbdcf29320886">power</a> (std::int64_t p, std::int64_t i)</td></tr>
<tr class="memdesc:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(p^i\).  <a href="#aa1b3094c46a9f69a9f1bbdcf29320886">More...</a><br /></td></tr>
<tr class="separator:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee3ffd9833b68af2a314e6b3c30641f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#afee3ffd9833b68af2a314e6b3c30641f">power2</a> (std::int64_t &amp;z, std::int64_t i)</td></tr>
<tr class="memdesc:afee3ffd9833b68af2a314e6b3c30641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(z = 2^i\).  <a href="#afee3ffd9833b68af2a314e6b3c30641f">More...</a><br /></td></tr>
<tr class="separator:afee3ffd9833b68af2a314e6b3c30641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab1dc3cf1db9f995cbf5bec7430e81393">power2</a> (NTL::ZZ &amp;z, std::int64_t i)</td></tr>
<tr class="memdesc:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(z = 2^i\).  <a href="#ab1dc3cf1db9f995cbf5bec7430e81393">More...</a><br /></td></tr>
<tr class="separator:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9abb8da9fdc5fa2c37d44165f8660aaf">mysqrt</a> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\).  <a href="#a9abb8da9fdc5fa2c37d44165f8660aaf">More...</a><br /></td></tr>
<tr class="separator:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae12db9335c229d7c60e570dab50ef05b">Lg</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2.  <a href="#ae12db9335c229d7c60e570dab50ef05b">More...</a><br /></td></tr>
<tr class="separator:ae12db9335c229d7c60e570dab50ef05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a12e4b6c931cf0a19642828796b3b3bef">Lg</a> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2.  <a href="#a12e4b6c931cf0a19642828796b3b3bef">More...</a><br /></td></tr>
<tr class="separator:a12e4b6c931cf0a19642828796b3b3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2">template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplItemLeft" align="right" valign="top">Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs</a> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of \(x\).  <a href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">More...</a><br /></td></tr>
<tr class="separator:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of <code>x</code>.  <a href="#a59016f13e4470ad17683b1cfeb70153c">More...</a><br /></td></tr>
<tr class="separator:a59016f13e4470ad17683b1cfeb70153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of x rounded to the NEAREST integer value.  <a href="#a15f15a1453b578cb49b2e3deda5a200d">More...</a><br /></td></tr>
<tr class="separator:a15f15a1453b578cb49b2e3deda5a200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9b920d83981962589ceb0d16d6d08"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a10b9b920d83981962589ceb0d16d6d08">Factorial</a> (int t)</td></tr>
<tr class="memdesc:a10b9b920d83981962589ceb0d16d6d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t.  <a href="#a10b9b920d83981962589ceb0d16d6d08">More...</a><br /></td></tr>
<tr class="separator:a10b9b920d83981962589ceb0d16d6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and modular arithmetic</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de LatMRG en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>.</dd></dl>
<p>This module offers function to perform division and find remainders in a standard way. These functions are usefull in the case where one wants to do divisions or find remainders of operations with negative operands. The reason is that <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> and primitive types do not use the same logic when doing calculations on negative numbers.</p>
<p>Basically, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> will always floor a division and C++ will always truncate a division (which effectively means the floor function is replaced by a roof function if the answer is a negative number). When calculating the remainder of x/y, both apply the same logic but get a different result because they do not do the same division. In both representations, we have that </p><p class="formulaDsp">
\[ y\cdot(x/y) + x%y = x. \]
</p>
<p> It turns out that, with negative values, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> will return an integer with the same sign as y where C++ will return an integer of opposite sign (but both will return the same number modulo y). </p>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a/b, truncates the fractionnal part and puts the result in q.  <a href="#aa9056e4da6e74d83c6061650caf9e59f">More...</a><br /></td></tr>
<tr class="separator:aa9056e4da6e74d83c6061650caf9e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo</a> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="memdesc:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of a/b and stores its positive equivalent mod b in r.  <a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">More...</a><br /></td></tr>
<tr class="separator:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\).  <a href="#aeccbd231b4002cadbaac0157871f5570">More...</a><br /></td></tr>
<tr class="separator:aeccbd231b4002cadbaac0157871f5570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <a href="#a76b74332cd4ded85d51dc6020b930772">More...</a><br /></td></tr>
<tr class="separator:a76b74332cd4ded85d51dc6020b930772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a14db19d396c104b730dd5ea23a7752b5">gcd</a> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm.  <a href="#a14db19d396c104b730dd5ea23a7752b5">More...</a><br /></td></tr>
<tr class="separator:a14db19d396c104b730dd5ea23a7752b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;E, Int &amp;F, Int &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm.  <a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">More...</a><br /></td></tr>
<tr class="separator:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are utilities to manipulate vectors ranging from instanciation to scalar product.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000023">Todo:</a></b></dt><dd>Functions of this section take the size of the input vectors as an argument with name d. Some of them assume d is the number of components of the vectors while somme of them assume that d+1 is the number of components of the vector. We need to uniformize that. </dd></dl>
</div></td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2256248f03b45f7125a46a05c49b8836">CreateVect</a> (Real *&amp;A, int d)</td></tr>
<tr class="memdesc:a2256248f03b45f7125a46a05c49b8836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0.  <a href="#a2256248f03b45f7125a46a05c49b8836">More...</a><br /></td></tr>
<tr class="separator:a2256248f03b45f7125a46a05c49b8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1b8b3b162c15420c29f622c74452ab5f">CreateVect</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a1b8b3b162c15420c29f622c74452ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0.  <a href="#a1b8b3b162c15420c29f622c74452ab5f">More...</a><br /></td></tr>
<tr class="separator:a1b8b3b162c15420c29f622c74452ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>.  <a href="#a3290d1c59f58412753021d37fd9059c3">More...</a><br /></td></tr>
<tr class="separator:a3290d1c59f58412753021d37fd9059c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>, destroying all the elements it contains.  <a href="#a74b9ac2e545b1a8e3febffe458488898">More...</a><br /></td></tr>
<tr class="separator:a74b9ac2e545b1a8e3febffe458488898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a80ff1882a1a3efdc5265695e4827bda5">SetZero</a> (Real *A, int d)</td></tr>
<tr class="memdesc:a80ff1882a1a3efdc5265695e4827bda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> of <code>A</code> to 0.  <a href="#a80ff1882a1a3efdc5265695e4827bda5">More...</a><br /></td></tr>
<tr class="separator:a80ff1882a1a3efdc5265695e4827bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3ae135eb75ddb3c6cb8f452afc34cf18">SetZero</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to 0.  <a href="#a3ae135eb75ddb3c6cb8f452afc34cf18">More...</a><br /></td></tr>
<tr class="separator:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a07e941416f7b2402d15045a459e4196e">SetValue</a> (Real *A, int d, const Real &amp;x)</td></tr>
<tr class="memdesc:a07e941416f7b2402d15045a459e4196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to the value <code>x</code>.  <a href="#a07e941416f7b2402d15045a459e4196e">More...</a><br /></td></tr>
<tr class="separator:a07e941416f7b2402d15045a459e4196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8c8c9d98d5ebd8cb7d73cec8a8e93c13">toString</a> (const Vect &amp;A, int c, int d, const char *sep=&quot; &quot;)</td></tr>
<tr class="memdesc:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>.  <a href="#a8c8c9d98d5ebd8cb7d73cec8a8e93c13">More...</a><br /></td></tr>
<tr class="separator:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0a994e5f949c8b1315d0324e7826240d">toString</a> (const Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a0a994e5f949c8b1315d0324e7826240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string.  <a href="#a0a994e5f949c8b1315d0324e7826240d">More...</a><br /></td></tr>
<tr class="separator:a0a994e5f949c8b1315d0324e7826240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a53d8462179e4ca773d33843c15c77afc">ProdScal</a> (const Vect1 &amp;A, const Vect2 &amp;B, int n, Scal &amp;D)</td></tr>
<tr class="memdesc:a53d8462179e4ca773d33843c15c77afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>.  <a href="#a53d8462179e4ca773d33843c15c77afc">More...</a><br /></td></tr>
<tr class="separator:a53d8462179e4ca773d33843c15c77afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplParams" colspan="2">template&lt;typename IntVec &gt; </td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8380e2ebec791f472a3634348bc0e22a">Invert</a> (const IntVec &amp;A, IntVec &amp;B, int n)</td></tr>
<tr class="memdesc:a8380e2ebec791f472a3634348bc0e22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values `[-A[n] -A[n-1] ...  <a href="#a8380e2ebec791f472a3634348bc0e22a">More...</a><br /></td></tr>
<tr class="separator:a8380e2ebec791f472a3634348bc0e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplParams" colspan="2">template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7022d363aa696d09b59c9499745466a6">CalcNorm</a> (const Vect &amp;V, int n, Scal &amp;S, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a7022d363aa696d09b59c9499745466a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>.  <a href="#a7022d363aa696d09b59c9499745466a6">More...</a><br /></td></tr>
<tr class="separator:a7022d363aa696d09b59c9499745466a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ada47b56ab96c49d7508b9379d0134472">CopyVect</a> (Vect &amp;A, const Vect &amp;B, int n)</td></tr>
<tr class="memdesc:ada47b56ab96c49d7508b9379d0134472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>n</code> components of vector <code>B</code> into vector <code>A</code>.  <a href="#ada47b56ab96c49d7508b9379d0134472">More...</a><br /></td></tr>
<tr class="separator:ada47b56ab96c49d7508b9379d0134472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplParams" colspan="2">template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">ModifVect</a> (Vect1 &amp;A, const Vect2 &amp;B, Scal x, int n)</td></tr>
<tr class="memdesc:ad43d2de9716e712790093eff2c12631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>.  <a href="#ad43d2de9716e712790093eff2c12631f">More...</a><br /></td></tr>
<tr class="separator:ad43d2de9716e712790093eff2c12631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a127802e517a91268330bad9930e5a5f4">ChangeSign</a> (Vect &amp;A, int n)</td></tr>
<tr class="memdesc:a127802e517a91268330bad9930e5a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign (multiplies by -1) the first <code>n</code> components of vector <code>A</code>.  <a href="#a127802e517a91268330bad9930e5a5f4">More...</a><br /></td></tr>
<tr class="separator:a127802e517a91268330bad9930e5a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2df72413bf638fb96e4a4d0e078828"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#adf2df72413bf638fb96e4a4d0e078828">GCD2vect</a> (std::vector&lt; std::int64_t &gt; V, int k, int n)</td></tr>
<tr class="memdesc:adf2df72413bf638fb96e4a4d0e078828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of <code>V[k],...,V[n-1]</code>.  <a href="#adf2df72413bf638fb96e4a4d0e078828">More...</a><br /></td></tr>
<tr class="separator:adf2df72413bf638fb96e4a4d0e078828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac21669d8af13d92327accdc26e9444ad">CreateMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:ac21669d8af13d92327accdc26e9444ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a square matrix <code>A</code> of dimensions \(d \times d\) and initializes its elements to 0.  <a href="#ac21669d8af13d92327accdc26e9444ad">More...</a><br /></td></tr>
<tr class="separator:ac21669d8af13d92327accdc26e9444ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#adfafd877b46442cc4b215448f25ccd7e">CreateMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:adfafd877b46442cc4b215448f25ccd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix <code>A</code> of dimensions \(\text{line} \times \text{col}\) and initializes its elements to 0.  <a href="#adfafd877b46442cc4b215448f25ccd7e">More...</a><br /></td></tr>
<tr class="separator:adfafd877b46442cc4b215448f25ccd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a5af883014a948b37a49d69f729db70f1">CreateMatr</a> (IntMat &amp;A, int d)</td></tr>
<tr class="memdesc:a5af883014a948b37a49d69f729db70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a square matrix of dimensions <code>d \times d</code> and re-initializes its elements to 0.  <a href="#a5af883014a948b37a49d69f729db70f1">More...</a><br /></td></tr>
<tr class="separator:a5af883014a948b37a49d69f729db70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a75474ce5f96fabf95eff6824df3d6f3d">CreateMatr</a> (IntMat &amp;A, int line, int col)</td></tr>
<tr class="memdesc:a75474ce5f96fabf95eff6824df3d6f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0.  <a href="#a75474ce5f96fabf95eff6824df3d6f3d">More...</a><br /></td></tr>
<tr class="separator:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a229c9368d745b9c4cae68c1b65e0e39c">DeleteMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:a229c9368d745b9c4cae68c1b65e0e39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d \times d\) matrix <code>A</code>.  <a href="#a229c9368d745b9c4cae68c1b65e0e39c">More...</a><br /></td></tr>
<tr class="separator:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0c884b60a0c4ee06455bf1c8e1819d35">DeleteMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix <code>A</code> of dimension \(\text{line} \times \text{col}\).  <a href="#a0c884b60a0c4ee06455bf1c8e1819d35">More...</a><br /></td></tr>
<tr class="separator:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (IntMat &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845" title="Sets x to 0. ">clear()</a></code> method on <code>A</code>.  <a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">More...</a><br /></td></tr>
<tr class="separator:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aac81709c183b536ab80b83384314457f">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int n)</td></tr>
<tr class="memdesc:aac81709c183b536ab80b83384314457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <a href="#aac81709c183b536ab80b83384314457f">More...</a><br /></td></tr>
<tr class="separator:aac81709c183b536ab80b83384314457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8f32e22915b91e8c763f35b62c1039d9">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int line, int col)</td></tr>
<tr class="memdesc:a8f32e22915b91e8c763f35b62c1039d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <a href="#a8f32e22915b91e8c763f35b62c1039d9">More...</a><br /></td></tr>
<tr class="separator:a8f32e22915b91e8c763f35b62c1039d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplParams" colspan="2">template&lt;typename MatT &gt; </td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab1f9c94abf76e8ce25eb60bb6d1bda2e">toStr</a> (const MatT &amp;mat, int d1, int d2)</td></tr>
<tr class="memdesc:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that is a representation of <code>mat</code>.  <a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">More...</a><br /></td></tr>
<tr class="separator:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8cff62df52a09d15ecd49a9c5e2be0"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a5d8cff62df52a09d15ecd49a9c5e2be0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a5d8cff62df52a09d15ecd49a9c5e2be0">CheckTriangular</a> (const Matr &amp;A, long dim, const Int m)</td></tr>
<tr class="memdesc:a5d8cff62df52a09d15ecd49a9c5e2be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>.  <a href="#a5d8cff62df52a09d15ecd49a9c5e2be0">More...</a><br /></td></tr>
<tr class="separator:a5d8cff62df52a09d15ecd49a9c5e2be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa519a1e0589932719c79b73c76bb1093">Triangularization</a> (Matr &amp;W, Matr &amp;V, int lin, int col, const Int &amp;m)</td></tr>
<tr class="memdesc:aa519a1e0589932719c79b73c76bb1093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an integer triangularization operation modulo <code>m</code> on the matrix <code>W</code> to obtain an upper triangular matrix <code>V</code>, dual to <code>W</code>.  <a href="#aa519a1e0589932719c79b73c76bb1093">More...</a><br /></td></tr>
<tr class="separator:aa519a1e0589932719c79b73c76bb1093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a17df0e6fdb1f11335eaf91f82ee298b0">CalcDual</a> (const Matr &amp;A, Matr &amp;B, int d, const Int &amp;m)</td></tr>
<tr class="memdesc:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the <code>m</code>-dual of the matrix <code>A</code>.  <a href="#a17df0e6fdb1f11335eaf91f82ee298b0">More...</a><br /></td></tr>
<tr class="separator:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:a49105dd8e915243488440f570b3951bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a49105dd8e915243488440f570b3951bd">MyExit</a> (int status, std::string msg)</td></tr>
<tr class="memdesc:a49105dd8e915243488440f570b3951bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special exit function.  <a href="#a49105dd8e915243488440f570b3951bd">More...</a><br /></td></tr>
<tr class="separator:a49105dd8e915243488440f570b3951bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the other functions implemented in this module, that have various usage in this program. </p>
</div></td></tr>
<tr class="memitem:aa332228978921670954fc35afb8d7440"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa332228978921670954fc35afb8d7440">IsOdd</a> (const std::int64_t &amp;x)</td></tr>
<tr class="memdesc:aa332228978921670954fc35afb8d7440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if <code>x</code> is odd.  <a href="#aa332228978921670954fc35afb8d7440">More...</a><br /></td></tr>
<tr class="separator:aa332228978921670954fc35afb8d7440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfdf172615c09b6a677ff935621632d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1cfdf172615c09b6a677ff935621632d">IsZero</a> (const std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a1cfdf172615c09b6a677ff935621632d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>bool</code> resulting of the statement <code>x == 0</code>.  <a href="#a1cfdf172615c09b6a677ff935621632d">More...</a><br /></td></tr>
<tr class="separator:a1cfdf172615c09b6a677ff935621632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fd74c4ea41ec1c1030a621dc788845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845">clear</a> (double &amp;x)</td></tr>
<tr class="memdesc:ab6fd74c4ea41ec1c1030a621dc788845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>x</code> to 0.  <a href="#ab6fd74c4ea41ec1c1030a621dc788845">More...</a><br /></td></tr>
<tr class="separator:ab6fd74c4ea41ec1c1030a621dc788845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738859ae42e8f85791ebb56705aa227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9738859ae42e8f85791ebb56705aa227">clear</a> (std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a9738859ae42e8f85791ebb56705aa227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>x</code> to 0.  <a href="#a9738859ae42e8f85791ebb56705aa227">More...</a><br /></td></tr>
<tr class="separator:a9738859ae42e8f85791ebb56705aa227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8196a81e178fdb095a0deaf8b0803614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8196a81e178fdb095a0deaf8b0803614">set9</a> (std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a8196a81e178fdb095a0deaf8b0803614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>x</code> to 1.  <a href="#a8196a81e178fdb095a0deaf8b0803614">More...</a><br /></td></tr>
<tr class="separator:a8196a81e178fdb095a0deaf8b0803614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378d927159f2724975f6d1264daf8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad378d927159f2724975f6d1264daf8e4">set9</a> (NTL::ZZ &amp;x)</td></tr>
<tr class="memdesc:ad378d927159f2724975f6d1264daf8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>x</code> to 1.  <a href="#ad378d927159f2724975f6d1264daf8e4">More...</a><br /></td></tr>
<tr class="separator:ad378d927159f2724975f6d1264daf8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac9adbd421a1148216c8eac1b7d96a5b8">MAX_LONG_DOUBLE</a> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\).  <a href="#ac9adbd421a1148216c8eac1b7d96a5b8">More...</a><br /></td></tr>
<tr class="separator:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540464b3215755b9a0ba65ebfba38f8"><td class="memItemLeft" align="right" valign="top">const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae540464b3215755b9a0ba65ebfba38f8">TWO_EXP</a> []</td></tr>
<tr class="memdesc:ae540464b3215755b9a0ba65ebfba38f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\).  <a href="#ae540464b3215755b9a0ba65ebfba38f8">More...</a><br /></td></tr>
<tr class="separator:ae540464b3215755b9a0ba65ebfba38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lattice namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&nbsp;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a> <code>PAL</code> is for the \(P_{\alpha}\) test. <br />
 <code>BAL</code> is for the bound on the \(P_{\alpha}\) test. <br />
 <code>NORMPAL</code> is for the \(P_{\alpha}\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. <br />
 <code>SEEKPAL</code> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>

</div>
</div>
<a id="a2cf3c4f4181718b7adc6f5e4513695a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3c4f4181718b7adc6f5e4513695a0">&#9670;&nbsp;</a></span>CriterionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">LatticeTester::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the merit criterion for ranking generators or lattices. </p>
<p><code>BEYER</code>: the figure of merit is the Beyer quotient \(Q_T\).<br />
 <code>SPECTRAL</code>: the figure of merit \(S_T\) is based on the spectral test.<br />
 <code>PALPHA</code>: the figure of merit is based on \(P_{\alpha}\).<br />
 <code>BOUND_JS</code>: the figure of merit is based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rSIN08a">[27]</a>&thinsp;.<br />
 </p>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&nbsp;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\). </p>
<p><code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best lattice.<br />
 <code>LAMINATED</code>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br />
 <code>ROGERS</code>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br />
 <code>MINKOWSKI</code>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br />
 <code>MINKL1</code>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br />
 <code>PALPHA_N</code>: the case of the \(P_{\alpha}\) test.<br />
 <code>NORMA_GENERIC</code>: the trivial normalization (= 1) used for the generic case when no useful normalization constant is known. </p>

</div>
</div>
<a id="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which norm is used to measure the length of vectors. </p>
<p>For \(X = (x_1,…,x_t)\),</p>
<p><code>SUPNORM</code> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br />
 <code>L1NORM</code> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br />
 <code>L2NORM</code> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br />
 <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>

</div>
</div>
<a id="ad78f099c800f4c648134967a45b91058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f099c800f4c648134967a45b91058">&#9670;&nbsp;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">LatticeTester::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates in which form and where the results will be sent. </p>
<p><a class="anchor" id="REF__Const_co_output"></a> <code>TERMINAL</code>: the results will appear only on the terminal screen.<br />
 <code>RES</code>: the results will be in plain text format and sent to a file with extension <code>.res</code>.<br />
 <code>TEX</code>: the results will be in LaTeX format and sent to a file with extension <code>.tex</code>.<br />
<code>GEN</code>: the results will be sent to a file with extension <code>.gen</code>. </p>

</div>
</div>
<a id="a94f96ff406f8b56147a2b7fd96209cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f96ff406f8b56147a2b7fd96209cb2">&#9670;&nbsp;</a></span>PrecisionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">LatticeTester::PrecisionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates in which precision the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> algorithms will be perfoms : <code>FP</code> &ndash; double <code>QP</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XD</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point) this is useful for large precision and magnitudes Generally speaking, the choice FP will be the fastest, but may be prone to roundoff errors and/or overflow. </p>

</div>
</div>
<a id="a191af830e61af769e233e1b03138520e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191af830e61af769e233e1b03138520e">&#9670;&nbsp;</a></span>PreReductionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">LatticeTester::PreReductionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the Prereduction Type (BKZ, LenstraLL, ...) used before applying the Branch and Bound procedure. </p>

</div>
</div>
<a id="a9b64954fb374b16e1fe991e435501d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b64954fb374b16e1fe991e435501d65">&#9670;&nbsp;</a></span>PrimeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">LatticeTester::PrimeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don’t care). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scal LatticeTester::abs </td>
          <td>(</td>
          <td class="paramtype">Scal&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of \(x\). </p>

</div>
</div>
<a id="a7e699673c28800e0563b14a05392d1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e699673c28800e0563b14a05392d1c0">&#9670;&nbsp;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are: </p><p class="formulaDsp">
\begin{align*} B_0(x) &amp;= 1 \\ B_1(x) &amp;= x - 1/2 \\ B_2(x) &amp;= x^2-x+1/6 \\ B_3(x) &amp;= x^3 - 3x^2/2 + x/2 \\ B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\ B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6 \\ B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42 \\ B_7(x) &amp;= x^7 - 7x^6/2 + 7x^5/2 - 7x^3/6 + x/6 \\ B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30. \end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a17df0e6fdb1f11335eaf91f82ee298b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17df0e6fdb1f11335eaf91f82ee298b0">&#9670;&nbsp;</a></span>CalcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the <code>m</code>-dual of the matrix <code>A</code>. </p>
<p>The result is placed in the matrix <code>B</code>. Only the first <code>d</code> lines and columns are considered.</p>
<p>The vectors of the basis (lines of A) need to verify the properties (i), (ii) (iii), (iv) as described in the article: R. Couture and P L'Ecuyer, Orbits and lattices for linear random number generators with composite moduli, Mathematics of Computation, Volume 65, Number 213, bottom of page 199.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000027">Todo:</a></b></dt><dd>Check the algorithm used here and explain how it works and what it takes for it to work. </dd></dl>

</div>
</div>
<a id="a7022d363aa696d09b59c9499745466a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022d363aa696d09b59c9499745466a6">&#9670;&nbsp;</a></span>CalcNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcNorm </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>. </p>
<p><code>Scal</code> has to be a floating point type. </p>

</div>
</div>
<a id="a127802e517a91268330bad9930e5a5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127802e517a91268330bad9930e5a5f4">&#9670;&nbsp;</a></span>ChangeSign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ChangeSign </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the sign (multiplies by -1) the first <code>n</code> components of vector <code>A</code>. </p>

</div>
</div>
<a id="a5d8cff62df52a09d15ecd49a9c5e2be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8cff62df52a09d15ecd49a9c5e2be0">&#9670;&nbsp;</a></span>CheckTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::CheckTriangular </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>. </p>
<p>This will return <code>true</code> if all the elements under the diagonal are equal to zero modulo <code>m</code> and <code>false</code> otherwise. If <code>m</code> is <code>0</code>, this function simply verifies that the matrix is triangular. </p>

</div>
</div>
<a id="ab6fd74c4ea41ec1c1030a621dc788845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fd74c4ea41ec1c1030a621dc788845">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::clear </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>x</code> to 0. </p>

</div>
</div>
<a id="a9738859ae42e8f85791ebb56705aa227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9738859ae42e8f85791ebb56705aa227">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::clear </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>x</code> to 0. </p>

</div>
</div>
<a id="aac81709c183b536ab80b83384314457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81709c183b536ab80b83384314457f">&#9670;&nbsp;</a></span>CopyMatr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(n \times n\). </p>

</div>
</div>
<a id="a8f32e22915b91e8c763f35b62c1039d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f32e22915b91e8c763f35b62c1039d9">&#9670;&nbsp;</a></span>CopyMatr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(line \times col\). </p>

</div>
</div>
<a id="ada47b56ab96c49d7508b9379d0134472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada47b56ab96c49d7508b9379d0134472">&#9670;&nbsp;</a></span>CopyVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <code>n</code> components of vector <code>B</code> into vector <code>A</code>. </p>

</div>
</div>
<a id="ac21669d8af13d92327accdc26e9444ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21669d8af13d92327accdc26e9444ad">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to a square matrix <code>A</code> of dimensions \(d \times d\) and initializes its elements to 0. </p>

</div>
</div>
<a id="adfafd877b46442cc4b215448f25ccd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfafd877b46442cc4b215448f25ccd7e">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the matrix <code>A</code> of dimensions \(\text{line} \times \text{col}\) and initializes its elements to 0. </p>

</div>
</div>
<a id="a5af883014a948b37a49d69f729db70f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af883014a948b37a49d69f729db70f1">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix <code>A</code> to a square matrix of dimensions <code>d \times d</code> and re-initializes its elements to 0. </p>

</div>
</div>
<a id="a75474ce5f96fabf95eff6824df3d6f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75474ce5f96fabf95eff6824df3d6f3d">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix <code>A</code> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0. </p>

</div>
</div>
<a id="a2256248f03b45f7125a46a05c49b8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2256248f03b45f7125a46a05c49b8836">&#9670;&nbsp;</a></span>CreateVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0. </p>
<p>`Real has to be a numeric type. </p>

</div>
</div>
<a id="a1b8b3b162c15420c29f622c74452ab5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8b3b162c15420c29f622c74452ab5f">&#9670;&nbsp;</a></span>CreateVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0. </p>
<p>The type <code>Vect</code> has to have a <code>resize(integer_type)</code> method that sets the size of the instance to the value of the argument. </p>

</div>
</div>
<a id="a229c9368d745b9c4cae68c1b65e0e39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229c9368d745b9c4cae68c1b65e0e39c">&#9670;&nbsp;</a></span>DeleteMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the \(d \times d\) matrix <code>A</code>. </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a0c884b60a0c4ee06455bf1c8e1819d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c884b60a0c4ee06455bf1c8e1819d35">&#9670;&nbsp;</a></span>DeleteMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix <code>A</code> of dimension \(\text{line} \times \text{col}\). </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">&#9670;&nbsp;</a></span>DeleteMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845" title="Sets x to 0. ">clear()</a></code> method on <code>A</code>. </p>
<p><code>A</code> has to have a <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845" title="Sets x to 0. ">clear()</a></code> method that frees the memory allocated to it. </p>

</div>
</div>
<a id="a3290d1c59f58412753021d37fd9059c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290d1c59f58412753021d37fd9059c3">&#9670;&nbsp;</a></span>DeleteVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>. </p>
<p>This calls <code>delete[]</code> on <code>A</code> so trying to access `A after using this is unsafe. </p>

</div>
</div>
<a id="a74b9ac2e545b1a8e3febffe458488898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b9ac2e545b1a8e3febffe458488898">&#9670;&nbsp;</a></span>DeleteVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>, destroying all the elements it contains. </p>
<p><code>Vect</code> type has to have a <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845" title="Sets x to 0. ">clear()</a></code> method that deallocates all the elements in the vector. </p>

</div>
</div>
<a id="a886c94b54767104cea58e0f1b6c0d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886c94b54767104cea58e0f1b6c0d11e">&#9670;&nbsp;</a></span>Digamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Digamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). </p>

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&nbsp;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\). </p>
<p>Truncates \(q\) to the nearest integer towards 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). This works with std::int64_t, NTL::ZZ and real numbers.</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a76b74332cd4ded85d51dc6020b930772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b74332cd4ded85d51dc6020b930772">&#9670;&nbsp;</a></span>DivideRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

</div>
</div>
<a id="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">&#9670;&nbsp;</a></span>Euclide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm. </p>
<p>This will store this gcd in <code>G</code> and also the linear combination that permits to get <code>G</code> from <code>A</code> and <code>B</code>. This function should work with std::int64_t and NTL::ZZ.</p>
<p>For \(A\) and \(B\) this will assign to \(C\), \(D\), \(E\), \(F\) and \(G\) values such that: </p><p class="formulaDsp">
\begin{align*} C a + D b &amp; = G = \mbox{GCD } (a,b)\\ E a + F b &amp; = 0. \end{align*}
</p>
 
</div>
</div>
<a id="a10b9b920d83981962589ceb0d16d6d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b9b920d83981962589ceb0d16d6d08">&#9670;&nbsp;</a></span>Factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::Factorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t. </p>

</div>
</div>
<a id="a0bb56e7569fb24800973df89d757f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb56e7569fb24800973df89d757f2fd">&#9670;&nbsp;</a></span>FourierC1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vJOE92b">[11]</a>) </p><p class="formulaDsp">
\[ S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}. \]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&nbsp;</a></span>FourierE1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. </p>
<p>Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a14db19d396c104b730dd5ea23a7752b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db19d396c104b730dd5ea23a7752b5">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::gcd </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm. </p>

</div>
</div>
<a id="adf2df72413bf638fb96e4a4d0e078828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2df72413bf638fb96e4a4d0e078828">&#9670;&nbsp;</a></span>GCD2vect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::GCD2vect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::int64_t &gt;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of <code>V[k],...,V[n-1]</code>. </p>

</div>
</div>
<a id="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">&#9670;&nbsp;</a></span>Harmonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the \(n\)-th harmonic number \(H_n = \sum_{j=1}^n 1/j\). </p>

</div>
</div>
<a id="a3aefa49a034495dcc46721c275f329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefa49a034495dcc46721c275f329b0">&#9670;&nbsp;</a></span>Harmonic2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum </p><p class="formulaDsp">
\[ \sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. </p>

</div>
</div>
<a id="ae5744c76f19028a3bd469d318108dd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5744c76f19028a3bd469d318108dd5e">&#9670;&nbsp;</a></span>initNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasIntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::initNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a>&lt; Int, BasIntMat &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the norm in config depending on it's normalizer. </p>

</div>
</div>
<a id="a8380e2ebec791f472a3634348bc0e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8380e2ebec791f472a3634348bc0e22a">&#9670;&nbsp;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values `[-A[n] -A[n-1] ... </p>
<p>-A[1] 1]<code>.</code>B<code>is assumed to be of dimension at least</code>n+1`.</p>
<p><b>OLD DOC</b>: Transforms the polynomial \( A_0 + A_1x^1 + \cdots + A_nx^n\) into \(x^n - A_1x^{n-1} - \cdots - A_n\). The result is put in <code>B</code>. </p><dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000025">Todo:</a></b></dt><dd>This function does not do what the old doc says. Check if it causes a problem where this function is called. </dd></dl>

</div>
</div>
<a id="aa332228978921670954fc35afb8d7440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa332228978921670954fc35afb8d7440">&#9670;&nbsp;</a></span>IsOdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::IsOdd </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if <code>x</code> is odd. </p>
<p>Returns 1 if it is odd, and 0 if it is even. </p><dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000028">Todo:</a></b></dt><dd>It is useless that this function is implemented. Look if it is removable. </dd></dl>

</div>
</div>
<a id="a1cfdf172615c09b6a677ff935621632d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfdf172615c09b6a677ff935621632d">&#9670;&nbsp;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::IsZero </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>bool</code> resulting of the statement <code>x == 0</code>. </p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000029">Todo:</a></b></dt><dd>It is useless that this function is implemented. Look if it is removable. </dd></dl>

</div>
</div>
<a id="a61a624270d67110531f2dea4c739eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a624270d67110531f2dea4c739eff5">&#9670;&nbsp;</a></span>lFactorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::lFactorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>
<p>Might throw if <code>t</code> is too large or if std::int64_t can't contain the factorial asked for. </p>

</div>
</div>
<a id="ae12db9335c229d7c60e570dab50ef05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12db9335c229d7c60e570dab50ef05b">&#9670;&nbsp;</a></span>Lg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="a12e4b6c931cf0a19642828796b3b3bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e4b6c931cf0a19642828796b3b3bef">&#9670;&nbsp;</a></span>Lg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="ad43d2de9716e712790093eff2c12631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43d2de9716e712790093eff2c12631f">&#9670;&nbsp;</a></span>ModifVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVect </td>
          <td>(</td>
          <td class="paramtype">Vect1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>. </p>
<p>This will modify <code>A</code>. This does wierd type convertion and might not work well if different types are used. </p>

</div>
</div>
<a id="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">&#9670;&nbsp;</a></span>Modulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of a/b and stores its positive equivalent mod b in r. </p>
<p>This works with std::int64_t, NTL::ZZ and real valued numbers. </p>

</div>
</div>
<a id="a49105dd8e915243488440f570b3951bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49105dd8e915243488440f570b3951bd">&#9670;&nbsp;</a></span>MyExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::MyExit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special exit function. </p>
<p><code>status</code> is the status code to return to the system, <code>msg</code> is the message to print upon exit. </p>

</div>
</div>
<a id="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb8da9fdc5fa2c37d44165f8660aaf">&#9670;&nbsp;</a></span>mysqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::mysqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). </p>

</div>
</div>
<a id="a42956b9be5474c04704701d5aba906cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42956b9be5474c04704701d5aba906cc">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, T, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>}. </p>

</div>
</div>
<a id="abf71d740b6bd3ef605406a4493939692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf71d740b6bd3ef605406a4493939692">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code></code>(first,second). </p>

</div>
</div>
<a id="a0f1e552bdaa65b87d6fd17c57edb040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1e552bdaa65b87d6fd17c57edb040e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a id="a8a8412cabdb8630ae40926d3257dddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8412cabdb8630ae40926d3257dddb2">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; K, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>}. </p>

</div>
</div>
<a id="aa1b3094c46a9f69a9f1bbdcf29320886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b3094c46a9f69a9f1bbdcf29320886">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::power </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(p^i\). </p>

</div>
</div>
<a id="afee3ffd9833b68af2a314e6b3c30641f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee3ffd9833b68af2a314e6b3c30641f">&#9670;&nbsp;</a></span>power2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::power2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(z = 2^i\). </p>

</div>
</div>
<a id="ab1dc3cf1db9f995cbf5bec7430e81393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dc3cf1db9f995cbf5bec7430e81393">&#9670;&nbsp;</a></span>power2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::power2 </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(z = 2^i\). </p>

</div>
</div>
<a id="a53d8462179e4ca773d33843c15c77afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d8462179e4ca773d33843c15c77afc">&#9670;&nbsp;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const Vect1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>. </p>
<p>There is a lot to consider when passing types to this function. The best for Vect1 to be the same type as Vect2 and for Scal to be the same as Int, and that those types are the ones stored in Vect1 and Vect2. </p><dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000024">Todo:</a></b></dt><dd>This uses so many types without check about them and also assumes all those types can be converted to each other without problem... The types here should be uniformized. THIS DOES NOT SEEM TO BE A VERY SAFE IMPLEMENTATION </dd></dl>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&nbsp;</a></span>Quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a/b, truncates the fractionnal part and puts the result in q. </p>
<p>This function is overloaded to work as specified on NTL::ZZ integers. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a56b8827c239bd1293eacd356e5cbe3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b8827c239bd1293eacd356e5cbe3b2">&#9670;&nbsp;</a></span>RandBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t LatticeTester::RandBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer. </p>
<p>It is imperative that \(1 \leq s \leq 64\) because the RNG is 64 bits wide. </p>

</div>
</div>
<a id="a8e829d77e42c8dbabc8f6e37eca2a714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e829d77e42c8dbabc8f6e37eca2a714">&#9670;&nbsp;</a></span>RandInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a uniform pseudo-random integer in \([i, j]\). </p>
<p>Note that the numbers \(i\) and \(j\) are part of the possible output. It is important that \(i &lt; j\) because the underlying arithmetic uses unsigned integers to store j-i+1 and that will be undefined behavior.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000022">Todo:</a></b></dt><dd>For some reason, this only uses the first 62 bits of the generator. Why? </dd></dl>

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&nbsp;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number will have 53 pseudo-random bits. </p>

</div>
</div>
<a id="a15f15a1453b578cb49b2e3deda5a200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f15a1453b578cb49b2e3deda5a200d">&#9670;&nbsp;</a></span>Round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::Round </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of x rounded to the NEAREST integer value. </p>
<p>(This does not truncate the integer value as is usual in computer arithmetic.) </p>

</div>
</div>
<a id="a8196a81e178fdb095a0deaf8b0803614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8196a81e178fdb095a0deaf8b0803614">&#9670;&nbsp;</a></span>set9() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::set9 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>x</code> to 1. </p>

</div>
</div>
<a id="ad378d927159f2724975f6d1264daf8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad378d927159f2724975f6d1264daf8e4">&#9670;&nbsp;</a></span>set9() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::set9 </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>x</code> to 1. </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&nbsp;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>Because of the constraints on the state, <code>seed</code> has to be \( &gt; 2\). If this is never called, a default seed will be used. </p>

</div>
</div>
<a id="a07e941416f7b2402d15045a459e4196e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e941416f7b2402d15045a459e4196e">&#9670;&nbsp;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetValue </td>
          <td>(</td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> components of <code>A</code> to the value <code>x</code>. </p>

</div>
</div>
<a id="a80ff1882a1a3efdc5265695e4827bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ff1882a1a3efdc5265695e4827bda5">&#9670;&nbsp;</a></span>SetZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> of <code>A</code> to 0. </p>

</div>
</div>
<a id="a3ae135eb75ddb3c6cb8f452afc34cf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae135eb75ddb3c6cb8f452afc34cf18">&#9670;&nbsp;</a></span>SetZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> components of <code>A</code> to 0. </p>

</div>
</div>
<a id="a59016f13e4470ad17683b1cfeb70153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59016f13e4470ad17683b1cfeb70153c">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of <code>x</code>. </p>
<p>The sign is 1 if <code>x&gt;0</code>, 0 if <code>x==0</code> and -1 if <code>x&lt;0</code>. </p>

</div>
</div>
<a id="ad4d16fed8fda92252dc423db28136932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d16fed8fda92252dc423db28136932">&#9670;&nbsp;</a></span>swap9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::swap9 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes references to two variables of a generic type and swaps their content. </p>
<p>This uses the assignment operator, so it might not always work well if this operator's implementation is not thorough. </p>

</div>
</div>
<a id="ab1f9c94abf76e8ce25eb60bb6d1bda2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">&#9670;&nbsp;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that is a representation of <code>mat</code>. </p>
<p>This string will represent the \(d1 \times d2\) submatrix of the first lines and colums of <code>mat</code>. </p>

</div>
</div>
<a id="a8c8c9d98d5ebd8cb7d73cec8a8e93c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8c9d98d5ebd8cb7d73cec8a8e93c13">&#9670;&nbsp;</a></span>toString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>. </p>
<p>In this string, components are separated by string <code>sep</code>. By default, <code>sep</code> is just a whitespace character. </p>

</div>
</div>
<a id="a0a994e5f949c8b1315d0324e7826240d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a994e5f949c8b1315d0324e7826240d">&#9670;&nbsp;</a></span>toString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string. </p>
<p>Calls <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8c8c9d98d5ebd8cb7d73cec8a8e93c13" title="Returns a string containing A[c] to A[d-1] formated as [A[c]sep...sepA[d-1]]. ">toString(const Vect&amp;, int, int, const char*)</a>. </p>

</div>
</div>
<a id="aa519a1e0589932719c79b73c76bb1093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa519a1e0589932719c79b73c76bb1093">&#9670;&nbsp;</a></span>Triangularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Triangularization </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an integer triangularization operation modulo <code>m</code> on the matrix <code>W</code> to obtain an upper triangular matrix <code>V</code>, dual to <code>W</code>. </p>
<p>However, the matrix <code>W</code> will be transformed too in order to preserve duality. Only the first <code>lin</code> lines and the first <code>col</code> columns of the matrices will be considered. The main idea is to transform a generating family of vectors into a basis (removing from the family the vectors that are linear combination of other vectors).</p>
<p>Refer to the article: R. Couture and P L'Ecuyer, Orbits and lattices for linear random number generators with composite moduli, Mathematics of Computation, Volume 65, Number 213, bottom of page 199. </p><dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000026">Todo:</a></b></dt><dd>Check the algorithm used here and what it does. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9adbd421a1148216c8eac1b7d96a5b8">&#9670;&nbsp;</a></span>MAX_LONG_DOUBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double LatticeTester::MAX_LONG_DOUBLE = 9007199254740992.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\). </p>

</div>
</div>
<a id="ae540464b3215755b9a0ba65ebfba38f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae540464b3215755b9a0ba65ebfba38f8">&#9670;&nbsp;</a></span>TWO_EXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::int64_t LatticeTester::TWO_EXP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,</div><div class="line">    65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216,</div><div class="line">    33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648,</div><div class="line">    4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472,</div><div class="line">    274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104,</div><div class="line">    8796093022208, 17592186044416, 35184372088832, 70368744177664,</div><div class="line">    140737488355328, 281474976710656, 562949953421312, 1125899906842624,</div><div class="line">    2251799813685248, 4503599627370496, 9007199254740992, 18014398509481984,</div><div class="line">    36028797018963968, 72057594037927936, 144115188075855872, 288230376151711744,</div><div class="line">    576460752303423488, 1152921504606846976, 2305843009213693952,</div><div class="line">    (std::int64_t)4611686018427387904U, (std::int64_t)9223372036854775808U }</div></div><!-- fragment -->
<p>Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated on Mon Sep 10 2018 16:43:21 for Lattice Tester Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
