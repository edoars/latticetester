<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Manual: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Manual
   &#160;<span id="projectnumber">0.1.0-templates-24</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LatticeTester Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lattice namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">A classes containing multiple sets of coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a <code>std::set&lt;std::size_t&gt;</code>.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d95/classLatticeTester_1_1IntFactor.html">IntFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects of this class are the "prime" factors in the decomposition of a positive integer.  <a href="../../d6/d95/classLatticeTester_1_1IntFactor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a skeleton for the implementation of different types of lattices of arbitrary rank.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a lattice and its basis and offers tools to do basic manipulations on lattice bases.  <a href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html">Lacunary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements sets of lacunary indices.  <a href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d22/classLatticeTester_1_1LatTestWriter.html">LatTestWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract class that does the writing of basic elements (<code>string</code>’s, <code>int</code>’s, <code>double</code>’s, etc.) into a file or into an <code>ostream</code>.  <a href="../../d7/d22/classLatticeTester_1_1LatTestWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db5/classLatticeTester_1_1LatTestWriterRes.html">LatTestWriterRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <code>Writer</code> abstract class to write basic elements in plain text format.  <a href="../../df/db5/classLatticeTester_1_1LatTestWriterRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html">LatticeAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class gathers other classes of <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace. ">LatticeTester</a> to create an object performing tests on lattices.  <a href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to save the configuration of a lattice test.  <a href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <em>best</em> theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in lattices.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in <em>laminated</em> lattices.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes which inherit from this base class are used in implementing bounds on the length of the shortest nonzero vector in a lattice <a class="el" href="../../d0/de3/citelist.html#CITEREF_mCON99a">[2]</a>&thinsp;.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html">NormaMinkL1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in space.  <a href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html">NormaMinkowski</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements *Minkowski*’s theoretical bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <code>Palpha</code>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <em>Rogers</em> bounds on the density of sphere packing.  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html">OrderDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order-dependent weights.  <a href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that can be used to read different kind of data from a file.  <a href="../../da/d47/classLatticeTester_1_1ParamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de7/classLatticeTester_1_1PODWeights.html">PODWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product and order-dependent (POD) weights.  <a href="../../d4/de7/classLatticeTester_1_1PODWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3e/classLatticeTester_1_1ProductWeights.html">ProductWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product weights.  <a href="../../da/d3e/classLatticeTester_1_1ProductWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection-dependent weights.  <a href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9a/classLatticeTester_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates random numbers (in fact pseudo-random numbers).  <a href="../../dc/d9a/classLatticeTester_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a general rank 1 lattice basis.  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements (or wraps from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>) all the functions that are needed to reduce a basis.  <a href="../../d8/de3/classLatticeTester_1_1Reducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db1/structLatticeTester_1_1specLatticeAnalysis.html">specLatticeAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure specializes certain members of <a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html" title="This class gathers other classes of LatticeTester to create an object performing tests on lattices...">LatticeAnalysis</a>.  <a href="../../d7/db1/structLatticeTester_1_1specLatticeAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df9/classLatticeTester_1_1Types.html">Types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets standard <code>typedef</code>’s for the types that can be used in <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace. ">LatticeTester</a>.  <a href="../../d6/df9/classLatticeTester_1_1Types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html">UniformWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement the same weight for all projections.  <a href="../../d7/d89/classLatticeTester_1_1UniformWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract weights class.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a951f7e7b03767aa0971dde55f9d328ec"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a951f7e7b03767aa0971dde55f9d328ec">Weight</a></td></tr>
<tr class="memdesc:a951f7e7b03767aa0971dde55f9d328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar weight type.  <a href="#a951f7e7b03767aa0971dde55f9d328ec">More...</a><br /></td></tr>
<tr class="separator:a951f7e7b03767aa0971dde55f9d328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> <tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which norm is used to measure the length of vectors.  <a href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f099c800f4c648134967a45b91058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a> <tr class="memdesc:ad78f099c800f4c648134967a45b91058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which form and where the results will be sent.  <a href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad78f099c800f4c648134967a45b91058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memItemLeft" align="right" valign="top"><a id="a94f96ff406f8b56147a2b7fd96209cb2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> <tr class="memdesc:a94f96ff406f8b56147a2b7fd96209cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which precision the <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> algorithms will be perfoms : <code>FP</code> &ndash; double <code>QP</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XD</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point) this is useful for large precision and magnitudes Generally speaking, the choice FP will be the fastest, but may be prone to roundoff errors and/or overflow. <br /></td></tr>
</td></tr>
<tr class="separator:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64954fb374b16e1fe991e435501d65"><td class="memItemLeft" align="right" valign="top"><a id="a9b64954fb374b16e1fe991e435501d65"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> <tr class="memdesc:a9b64954fb374b16e1fe991e435501d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don’t care). <br /></td></tr>
</td></tr>
<tr class="separator:a9b64954fb374b16e1fe991e435501d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> <tr class="memdesc:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the merit criterion for ranking generators or lattices.  <a href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> <tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\).  <a href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> <tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191af830e61af769e233e1b03138520e"><td class="memItemLeft" align="right" valign="top"><a id="a191af830e61af769e233e1b03138520e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> <tr class="memdesc:a191af830e61af769e233e1b03138520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the Prereduction Type (BKZ, LenstraLL, ...) used before applying the Branch and Bound procedure. <br /></td></tr>
</td></tr>
<tr class="separator:a191af830e61af769e233e1b03138520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a14ffc84b470dfb03f7105b232cec39a1"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:a14ffc84b470dfb03f7105b232cec39a1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a14ffc84b470dfb03f7105b232cec39a1">ShortestVector</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a14ffc84b470dfb03f7105b232cec39a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows computation of the shortest non-zero vector in a lattice, according to the selected norm.  <a href="#a14ffc84b470dfb03f7105b232cec39a1">More...</a><br /></td></tr>
<tr class="separator:a14ffc84b470dfb03f7105b232cec39a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd47798df149becb393bf34941f1712"><td class="memTemplParams" colspan="2"><a id="a2bd47798df149becb393bf34941f1712"></a>
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:a2bd47798df149becb393bf34941f1712"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2bd47798df149becb393bf34941f1712">ShortestVector</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a2bd47798df149becb393bf34941f1712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB. <br /></td></tr>
<tr class="separator:a2bd47798df149becb393bf34941f1712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0315802d7f789ba576dbab54e9b7ebc"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:aa0315802d7f789ba576dbab54e9b7ebc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa0315802d7f789ba576dbab54e9b7ebc">FigureOfMerit</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> normalizerType, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:aa0315802d7f789ba576dbab54e9b7ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the Figure of Merit to a given matrix, according to a normalization criteria.  <a href="#aa0315802d7f789ba576dbab54e9b7ebc">More...</a><br /></td></tr>
<tr class="separator:aa0315802d7f789ba576dbab54e9b7ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754d3aa33908b5eea68d0d448b83305a"><td class="memTemplParams" colspan="2"><a id="a754d3aa33908b5eea68d0d448b83305a"></a>
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:a754d3aa33908b5eea68d0d448b83305a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a754d3aa33908b5eea68d0d448b83305a">FigureOfMerit</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> normalizerType, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a754d3aa33908b5eea68d0d448b83305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB. <br /></td></tr>
<tr class="separator:a754d3aa33908b5eea68d0d448b83305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa671528908af203438e7969df2b35eae"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:aa671528908af203438e7969df2b35eae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa671528908af203438e7969df2b35eae">MinkowskiReduction</a> (BasIntMat &amp;matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:aa671528908af203438e7969df2b35eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reduces a basis to a Minkowski-reduced basis.  <a href="#aa671528908af203438e7969df2b35eae">More...</a><br /></td></tr>
<tr class="separator:aa671528908af203438e7969df2b35eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8cd4e6df666fe0456558fa295a37ac"><td class="memTemplParams" colspan="2"><a id="ade8cd4e6df666fe0456558fa295a37ac"></a>
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:ade8cd4e6df666fe0456558fa295a37ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ade8cd4e6df666fe0456558fa295a37ac">MinkowskiReduction</a> (BasIntMat &amp;matrix, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:ade8cd4e6df666fe0456558fa295a37ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB. <br /></td></tr>
<tr class="separator:ade8cd4e6df666fe0456558fa295a37ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15e63c629906c3f418221828a4fae37"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:aa15e63c629906c3f418221828a4fae37"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa15e63c629906c3f418221828a4fae37">FigureOfMeritBeyer</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:aa15e63c629906c3f418221828a4fae37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the Figure of Merit to a given matrix, according to the Beyer criteria.  <a href="#aa15e63c629906c3f418221828a4fae37">More...</a><br /></td></tr>
<tr class="separator:aa15e63c629906c3f418221828a4fae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66cb03d376399e369a7dd1e3a25e6b9"><td class="memTemplParams" colspan="2"><a id="ab66cb03d376399e369a7dd1e3a25e6b9"></a>
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </td></tr>
<tr class="memitem:ab66cb03d376399e369a7dd1e3a25e6b9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab66cb03d376399e369a7dd1e3a25e6b9">FigureOfMeritBeyer</a> (BasIntMat matrix, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=BKZ, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=DOUBLE, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:ab66cb03d376399e369a7dd1e3a25e6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB. <br /></td></tr>
<tr class="separator:ab66cb03d376399e369a7dd1e3a25e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a624270d67110531f2dea4c739eff5"><td class="memItemLeft" align="right" valign="top"><a id="a61a624270d67110531f2dea4c739eff5"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a61a624270d67110531f2dea4c739eff5">lFactorial</a> (int t)</td></tr>
<tr class="memdesc:a61a624270d67110531f2dea4c739eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\). <br /></td></tr>
<tr class="separator:a61a624270d67110531f2dea4c739eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top"><a id="a886c94b54767104cea58e0f1b6c0d11e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a886c94b54767104cea58e0f1b6c0d11e">Digamma</a> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). <br /></td></tr>
<tr class="separator:a886c94b54767104cea58e0f1b6c0d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e699673c28800e0563b14a05392d1c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7e699673c28800e0563b14a05392d1c0">BernoulliPoly</a> (int n, double x)</td></tr>
<tr class="memdesc:a7e699673c28800e0563b14a05392d1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <a href="#a7e699673c28800e0563b14a05392d1c0">More...</a><br /></td></tr>
<tr class="separator:a7e699673c28800e0563b14a05392d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top"><a id="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a61a4b5013c295f9f07b9b2d8f26ee5f4">Harmonic</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n = \sum_{j=1}^n 1/j\). <br /></td></tr>
<tr class="separator:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top"><a id="a3aefa49a034495dcc46721c275f329b0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum </p><p class="formulaDsp">
\[ \sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. <br /></td></tr>
<tr class="separator:a3aefa49a034495dcc46721c275f329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top"><a id="a0bb56e7569fb24800973df89d757f2fd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vJOE92b">[11]</a>) </p><p class="formulaDsp">
\[ S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}. \]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). <br /></td></tr>
<tr class="separator:a0bb56e7569fb24800973df89d757f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes.  <a href="#ab5f708fa0e8d6aa53427b3e8927f5504">More...</a><br /></td></tr>
<tr class="separator:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5744c76f19028a3bd469d318108dd5e"><td class="memTemplParams" colspan="2"><a id="ae5744c76f19028a3bd469d318108dd5e"></a>
template&lt;typename Int , typename BasIntMat &gt; </td></tr>
<tr class="memitem:ae5744c76f19028a3bd469d318108dd5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae5744c76f19028a3bd469d318108dd5e">initNorm</a> (<a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a>&lt; Int, BasIntMat &gt; &amp;config)</td></tr>
<tr class="memdesc:ae5744c76f19028a3bd469d318108dd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the norm in config depending on it's normalizer. <br /></td></tr>
<tr class="separator:ae5744c76f19028a3bd469d318108dd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2"><a id="ad4d16fed8fda92252dc423db28136932"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of <code>x</code> and <code>y</code>. <br /></td></tr>
<tr class="separator:ad4d16fed8fda92252dc423db28136932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42956b9be5474c04704701d5aba906cc"><td class="memTemplParams" colspan="2"><a id="a42956b9be5474c04704701d5aba906cc"></a>
template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:a42956b9be5474c04704701d5aba906cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a42956b9be5474c04704701d5aba906cc">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a42956b9be5474c04704701d5aba906cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">}. <br /></td></tr>
<tr class="separator:a42956b9be5474c04704701d5aba906cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf71d740b6bd3ef605406a4493939692"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:abf71d740b6bd3ef605406a4493939692"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abf71d740b6bd3ef605406a4493939692">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:abf71d740b6bd3ef605406a4493939692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#abf71d740b6bd3ef605406a4493939692">More...</a><br /></td></tr>
<tr class="separator:abf71d740b6bd3ef605406a4493939692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0f1e552bdaa65b87d6fd17c57edb040e">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#a0f1e552bdaa65b87d6fd17c57edb040e">More...</a><br /></td></tr>
<tr class="separator:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8412cabdb8630ae40926d3257dddb2"><td class="memTemplParams" colspan="2"><a id="a8a8412cabdb8630ae40926d3257dddb2"></a>
template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a8a8412cabdb8630ae40926d3257dddb2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8a8412cabdb8630ae40926d3257dddb2">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a8a8412cabdb8630ae40926d3257dddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">}. <br /></td></tr>
<tr class="separator:a8a8412cabdb8630ae40926d3257dddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">toString functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Useful functions for printing the <code>enum</code> constants in this module.</p>
<p>Returns the <code>enum</code> constants in this module as strings. </p>
</div></td></tr>
<tr class="memitem:a008a0f13f3dd13f786385093e6bff477"><td class="memItemLeft" align="right" valign="top"><a id="a008a0f13f3dd13f786385093e6bff477"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorm</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>)</td></tr>
<tr class="separator:a008a0f13f3dd13f786385093e6bff477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822e2af752a071d540ed96e8b5919ed"><td class="memItemLeft" align="right" valign="top"><a id="a9822e2af752a071d540ed96e8b5919ed"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrime</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a>)</td></tr>
<tr class="separator:a9822e2af752a071d540ed96e8b5919ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce69d86ac936dd6fc557c0dfa57a39b"><td class="memItemLeft" align="right" valign="top"><a id="a7ce69d86ac936dd6fc557c0dfa57a39b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCriterion</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a>)</td></tr>
<tr class="separator:a7ce69d86ac936dd6fc557c0dfa57a39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9d3e6f7b852580034df6ba3e2eed5"><td class="memItemLeft" align="right" valign="top"><a id="a8ed9d3e6f7b852580034df6ba3e2eed5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorma</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>)</td></tr>
<tr class="separator:a8ed9d3e6f7b852580034df6ba3e2eed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ef31cf1e22bf8f4bba3f46bf74435f"><td class="memItemLeft" align="right" valign="top"><a id="ae8ef31cf1e22bf8f4bba3f46bf74435f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCalc</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a>)</td></tr>
<tr class="separator:ae8ef31cf1e22bf8f4bba3f46bf74435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58006e68111d503cf4096bf9ffc9546"><td class="memItemLeft" align="right" valign="top"><a id="ae58006e68111d503cf4096bf9ffc9546"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPreRed</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>)</td></tr>
<tr class="separator:ae58006e68111d503cf4096bf9ffc9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfcce9fb68f4fe2a1fd58f164ed3bbf"><td class="memItemLeft" align="right" valign="top"><a id="aabfcce9fb68f4fe2a1fd58f164ed3bbf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringOutput</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a>)</td></tr>
<tr class="separator:aabfcce9fb68f4fe2a1fd58f164ed3bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139260fd72d3392ffac14fede81a693d"><td class="memItemLeft" align="right" valign="top"><a id="a139260fd72d3392ffac14fede81a693d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrecision</b> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>)</td></tr>
<tr class="separator:a139260fd72d3392ffac14fede81a693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <a href="#abba336d3a5abb22b8367ddfa37a713e4">More...</a><br /></td></tr>
<tr class="separator:abba336d3a5abb22b8367ddfa37a713e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8e829d77e42c8dbabc8f6e37eca2a714">RandInt</a> (int i, int j)</td></tr>
<tr class="memdesc:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random integer in \([i, j]\).  <a href="#a8e829d77e42c8dbabc8f6e37eca2a714">More...</a><br /></td></tr>
<tr class="separator:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memItemLeft" align="right" valign="top"><a id="a56b8827c239bd1293eacd356e5cbe3b2"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a56b8827c239bd1293eacd356e5cbe3b2">RandBits</a> (int s)</td></tr>
<tr class="memdesc:a56b8827c239bd1293eacd356e5cbe3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns random blocks of \(s\) bits ( \(s\)-bit integers). <br /></td></tr>
<tr class="separator:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <a href="#a1a68bc6b1e81a03d09ea07fa9efed658">More...</a><br /></td></tr>
<tr class="separator:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa332228978921670954fc35afb8d7440"><td class="memItemLeft" align="right" valign="top"><a id="aa332228978921670954fc35afb8d7440"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa332228978921670954fc35afb8d7440">IsOdd</a> (const std::int64_t &amp;x)</td></tr>
<tr class="memdesc:aa332228978921670954fc35afb8d7440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if \(x\) is odd, and 0 otherwise. <br /></td></tr>
<tr class="separator:aa332228978921670954fc35afb8d7440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfdf172615c09b6a677ff935621632d"><td class="memItemLeft" align="right" valign="top"><a id="a1cfdf172615c09b6a677ff935621632d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1cfdf172615c09b6a677ff935621632d">IsZero</a> (const std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a1cfdf172615c09b6a677ff935621632d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if \(x = 0\). <br /></td></tr>
<tr class="separator:a1cfdf172615c09b6a677ff935621632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fd74c4ea41ec1c1030a621dc788845"><td class="memItemLeft" align="right" valign="top"><a id="ab6fd74c4ea41ec1c1030a621dc788845"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845">clear</a> (double &amp;x)</td></tr>
<tr class="memdesc:ab6fd74c4ea41ec1c1030a621dc788845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 0. <br /></td></tr>
<tr class="separator:ab6fd74c4ea41ec1c1030a621dc788845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738859ae42e8f85791ebb56705aa227"><td class="memItemLeft" align="right" valign="top"><a id="a9738859ae42e8f85791ebb56705aa227"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9738859ae42e8f85791ebb56705aa227">clear</a> (std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a9738859ae42e8f85791ebb56705aa227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 0. <br /></td></tr>
<tr class="separator:a9738859ae42e8f85791ebb56705aa227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8196a81e178fdb095a0deaf8b0803614"><td class="memItemLeft" align="right" valign="top"><a id="a8196a81e178fdb095a0deaf8b0803614"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8196a81e178fdb095a0deaf8b0803614">set9</a> (std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a8196a81e178fdb095a0deaf8b0803614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 1. <br /></td></tr>
<tr class="separator:a8196a81e178fdb095a0deaf8b0803614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378d927159f2724975f6d1264daf8e4"><td class="memItemLeft" align="right" valign="top"><a id="ad378d927159f2724975f6d1264daf8e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad378d927159f2724975f6d1264daf8e4">set9</a> (NTL::ZZ &amp;x)</td></tr>
<tr class="memdesc:ad378d927159f2724975f6d1264daf8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 1. <br /></td></tr>
<tr class="separator:ad378d927159f2724975f6d1264daf8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr class="memitem:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="memItemLeft" align="right" valign="top"><a id="aa1b3094c46a9f69a9f1bbdcf29320886"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa1b3094c46a9f69a9f1bbdcf29320886">power</a> (std::int64_t p, std::int64_t i)</td></tr>
<tr class="memdesc:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(p^i\). <br /></td></tr>
<tr class="separator:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee3ffd9833b68af2a314e6b3c30641f"><td class="memItemLeft" align="right" valign="top"><a id="afee3ffd9833b68af2a314e6b3c30641f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#afee3ffd9833b68af2a314e6b3c30641f">power2</a> (std::int64_t &amp;z, std::int64_t i)</td></tr>
<tr class="memdesc:afee3ffd9833b68af2a314e6b3c30641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(z = 2^i\). <br /></td></tr>
<tr class="separator:afee3ffd9833b68af2a314e6b3c30641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="memItemLeft" align="right" valign="top"><a id="ab1dc3cf1db9f995cbf5bec7430e81393"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab1dc3cf1db9f995cbf5bec7430e81393">power2</a> (NTL::ZZ &amp;z, std::int64_t i)</td></tr>
<tr class="memdesc:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(z = 2^i\). <br /></td></tr>
<tr class="separator:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top"><a id="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9abb8da9fdc5fa2c37d44165f8660aaf">mysqrt</a> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). <br /></td></tr>
<tr class="separator:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f48ff79454c1d449bc309bebdcbdc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac57f48ff79454c1d449bc309bebdcbdc">SqrRoot</a> (double x)</td></tr>
<tr class="memdesc:ac57f48ff79454c1d449bc309bebdcbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\).  <a href="#ac57f48ff79454c1d449bc309bebdcbdc">More...</a><br /></td></tr>
<tr class="separator:ac57f48ff79454c1d449bc309bebdcbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2"><a id="ae12db9335c229d7c60e570dab50ef05b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae12db9335c229d7c60e570dab50ef05b">Lg</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of \(x\) in base 2. <br /></td></tr>
<tr class="separator:ae12db9335c229d7c60e570dab50ef05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top"><a id="a12e4b6c931cf0a19642828796b3b3bef"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a12e4b6c931cf0a19642828796b3b3bef">Lg</a> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of \(x\) in base 2. <br /></td></tr>
<tr class="separator:a12e4b6c931cf0a19642828796b3b3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2"><a id="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplItemLeft" align="right" valign="top">Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs</a> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value. <br /></td></tr>
<tr class="separator:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2"><a id="a59016f13e4470ad17683b1cfeb70153c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1, 0 or \(-1\) depending on whether \(x&gt; 0\), \(x= 0\) or \(x&lt; 0\) respectively. <br /></td></tr>
<tr class="separator:a59016f13e4470ad17683b1cfeb70153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2"><a id="a15f15a1453b578cb49b2e3deda5a200d"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds to the nearest integer value. <br /></td></tr>
<tr class="separator:a15f15a1453b578cb49b2e3deda5a200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9b920d83981962589ceb0d16d6d08"><td class="memItemLeft" align="right" valign="top"><a id="a10b9b920d83981962589ceb0d16d6d08"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a10b9b920d83981962589ceb0d16d6d08">Factorial</a> (int t)</td></tr>
<tr class="memdesc:a10b9b920d83981962589ceb0d16d6d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\). <br /></td></tr>
<tr class="separator:a10b9b920d83981962589ceb0d16d6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and remainder</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>For negative operands, the <code>/</code> and <code>%</code> operators do not give the same results for <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> large integers <code>ZZ</code> and for primitive types <code>int</code> and <code>std::int64_t</code>.</p>
<p>The negative quotient differs by 1 and the remainder also differs. Thus the following small <code>inline</code> functions for division and remainder. </p><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de LatMRG en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>. </dd></dl>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(q = a/b\) by dropping the fractionnal part, i.e.  <a href="#aa9056e4da6e74d83c6061650caf9e59f">More...</a><br /></td></tr>
<tr class="separator:aa9056e4da6e74d83c6061650caf9e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c40ca56dbbbaeeae0b5ab38ac83de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa7c40ca56dbbbaeeae0b5ab38ac83de1">Quotient</a> (const NTL::ZZ &amp;a, const NTL::ZZ &amp;b, NTL::ZZ &amp;q)</td></tr>
<tr class="memdesc:aa7c40ca56dbbbaeeae0b5ab38ac83de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(q = a/b\) by dropping the fractionnal part, i.e.  <a href="#aa7c40ca56dbbbaeeae0b5ab38ac83de1">More...</a><br /></td></tr>
<tr class="separator:aa7c40ca56dbbbaeeae0b5ab38ac83de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2"><a id="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Modulo</b> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="separator:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fd3ae7e7a02590cc97b3f3f28e0638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab3fd3ae7e7a02590cc97b3f3f28e0638">Modulo</a> (const std::int64_t &amp;a, const std::int64_t &amp;b, std::int64_t &amp;r)</td></tr>
<tr class="memdesc:ab3fd3ae7e7a02590cc97b3f3f28e0638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the "positive" remainder \(r = a \bmod b\), i.e.  <a href="#ab3fd3ae7e7a02590cc97b3f3f28e0638">More...</a><br /></td></tr>
<tr class="separator:ab3fd3ae7e7a02590cc97b3f3f28e0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37596db3ece874abb24b32cab2873e33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a37596db3ece874abb24b32cab2873e33">Modulo</a> (const NTL::ZZ &amp;a, const NTL::ZZ &amp;b, NTL::ZZ &amp;r)</td></tr>
<tr class="memdesc:a37596db3ece874abb24b32cab2873e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the "positive" remainder \(r = a \bmod b\), i.e.  <a href="#a37596db3ece874abb24b32cab2873e33">More...</a><br /></td></tr>
<tr class="separator:a37596db3ece874abb24b32cab2873e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\).  <a href="#aeccbd231b4002cadbaac0157871f5570">More...</a><br /></td></tr>
<tr class="separator:aeccbd231b4002cadbaac0157871f5570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e86545bb8987e61e30693e09a60113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a96e86545bb8987e61e30693e09a60113">Divide</a> (std::int64_t &amp;q, std::int64_t &amp;r, const std::int64_t &amp;a, const std::int64_t &amp;b)</td></tr>
<tr class="memdesc:a96e86545bb8987e61e30693e09a60113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0.  <a href="#a96e86545bb8987e61e30693e09a60113">More...</a><br /></td></tr>
<tr class="separator:a96e86545bb8987e61e30693e09a60113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299b8335f9a690fad8b7838db6678ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab299b8335f9a690fad8b7838db6678ad">Divide</a> (NTL::ZZ &amp;q, NTL::ZZ &amp;r, const NTL::ZZ &amp;a, const NTL::ZZ &amp;b)</td></tr>
<tr class="memdesc:ab299b8335f9a690fad8b7838db6678ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0.  <a href="#ab299b8335f9a690fad8b7838db6678ad">More...</a><br /></td></tr>
<tr class="separator:ab299b8335f9a690fad8b7838db6678ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756f03c94dc21f7dbf6aad8cb6f9f4c1"><td class="memItemLeft" align="right" valign="top"><a id="a756f03c94dc21f7dbf6aad8cb6f9f4c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a756f03c94dc21f7dbf6aad8cb6f9f4c1">div</a> (std::int64_t &amp;a, const std::int64_t &amp;b, const std::int64_t &amp;d)</td></tr>
<tr class="memdesc:a756f03c94dc21f7dbf6aad8cb6f9f4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer division: \(a = b/d\). <br /></td></tr>
<tr class="separator:a756f03c94dc21f7dbf6aad8cb6f9f4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2"><a id="a76b74332cd4ded85d51dc6020b930772"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). <br /></td></tr>
<tr class="separator:a76b74332cd4ded85d51dc6020b930772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a1477c8a8f0bb66d862e9ab07eccd"><td class="memItemLeft" align="right" valign="top"><a id="a731a1477c8a8f0bb66d862e9ab07eccd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a731a1477c8a8f0bb66d862e9ab07eccd">DivideRound</a> (const std::int64_t &amp;a, const std::int64_t &amp;b, std::int64_t &amp;q)</td></tr>
<tr class="memdesc:a731a1477c8a8f0bb66d862e9ab07eccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). <br /></td></tr>
<tr class="separator:a731a1477c8a8f0bb66d862e9ab07eccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eec1640aff38a01eea3be0e4438522"><td class="memItemLeft" align="right" valign="top"><a id="a29eec1640aff38a01eea3be0e4438522"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a29eec1640aff38a01eea3be0e4438522">DivideRound</a> (const NTL::ZZ &amp;a, const NTL::ZZ &amp;b, NTL::ZZ &amp;q)</td></tr>
<tr class="memdesc:a29eec1640aff38a01eea3be0e4438522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). <br /></td></tr>
<tr class="separator:a29eec1640aff38a01eea3be0e4438522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a14db19d396c104b730dd5ea23a7752b5">gcd</a> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\).  <a href="#a14db19d396c104b730dd5ea23a7752b5">More...</a><br /></td></tr>
<tr class="separator:a14db19d396c104b730dd5ea23a7752b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2"><a id="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;E, Int &amp;F, Int &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For given \(a\) and \(b\), returns the values \(C\), \(D\), \(E\), \(F\) and \(G\) such that: </p><p class="formulaDsp">
\begin{align*} C a + D b &amp; = G = \mbox{GCD } (a,b) \\ E a + F b &amp; = 0. \end{align*}
</p>
<p>. <br /></td></tr>
<tr class="separator:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplParams" colspan="2"><a id="a2256248f03b45f7125a46a05c49b8836"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2256248f03b45f7125a46a05c49b8836">CreateVect</a> (Real *&amp;A, int d)</td></tr>
<tr class="memdesc:a2256248f03b45f7125a46a05c49b8836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the vector \(A\) of dimensions \(d\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:a2256248f03b45f7125a46a05c49b8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2"><a id="a3290d1c59f58412753021d37fd9059c3"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector \(A\). <br /></td></tr>
<tr class="separator:a3290d1c59f58412753021d37fd9059c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplParams" colspan="2"><a id="a1b8b3b162c15420c29f622c74452ab5f"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1b8b3b162c15420c29f622c74452ab5f">CreateVect</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a1b8b3b162c15420c29f622c74452ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector \(A\) of dimensions \(d+1\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:a1b8b3b162c15420c29f622c74452ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2"><a id="a74b9ac2e545b1a8e3febffe458488898"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector \(A\). <br /></td></tr>
<tr class="separator:a74b9ac2e545b1a8e3febffe458488898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplParams" colspan="2"><a id="a80ff1882a1a3efdc5265695e4827bda5"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a80ff1882a1a3efdc5265695e4827bda5">SetZero</a> (Real *A, int d)</td></tr>
<tr class="memdesc:a80ff1882a1a3efdc5265695e4827bda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets components \([0..d-1]\) of \(A\) to 0. <br /></td></tr>
<tr class="separator:a80ff1882a1a3efdc5265695e4827bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplParams" colspan="2"><a id="a3ae135eb75ddb3c6cb8f452afc34cf18"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3ae135eb75ddb3c6cb8f452afc34cf18">SetZero</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets components \([0..d-1]\) of \(A\) to 0. <br /></td></tr>
<tr class="separator:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplParams" colspan="2"><a id="a07e941416f7b2402d15045a459e4196e"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a07e941416f7b2402d15045a459e4196e">SetValue</a> (Real *A, int d, const Real &amp;x)</td></tr>
<tr class="memdesc:a07e941416f7b2402d15045a459e4196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all components \([0..d]\) of \(A\) to the value \(x\). <br /></td></tr>
<tr class="separator:a07e941416f7b2402d15045a459e4196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab3cd721290c62bbed850fac763aa9"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ac0ab3cd721290c62bbed850fac763aa9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac0ab3cd721290c62bbed850fac763aa9">toString</a> (const Vect &amp;A, int c, int d, const char *sep)</td></tr>
<tr class="memdesc:ac0ab3cd721290c62bbed850fac763aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([c..d-1]\) of vector \(A\) as a string.  <a href="#ac0ab3cd721290c62bbed850fac763aa9">More...</a><br /></td></tr>
<tr class="separator:ac0ab3cd721290c62bbed850fac763aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5337d95017557ef829bacfe9336d8c"><td class="memTemplParams" colspan="2"><a id="a7f5337d95017557ef829bacfe9336d8c"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a7f5337d95017557ef829bacfe9336d8c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7f5337d95017557ef829bacfe9336d8c">toString</a> (const Vect &amp;A, int c, int d)</td></tr>
<tr class="memdesc:a7f5337d95017557ef829bacfe9336d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([c..d]\) of vector \(A\) as a string. <br /></td></tr>
<tr class="separator:a7f5337d95017557ef829bacfe9336d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplParams" colspan="2"><a id="a0a994e5f949c8b1315d0324e7826240d"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0a994e5f949c8b1315d0324e7826240d">toString</a> (const Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a0a994e5f949c8b1315d0324e7826240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([0..d-1]\) of vector \(A\) as a string. <br /></td></tr>
<tr class="separator:a0a994e5f949c8b1315d0324e7826240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a53d8462179e4ca773d33843c15c77afc">ProdScal</a> (const Vect1 &amp;A, const Vect2 &amp;B, int n, Scal &amp;D)</td></tr>
<tr class="memdesc:a53d8462179e4ca773d33843c15c77afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors \(A\) and \(B\), using components \([0..n-1]\), and puts the result in \(D\).  <a href="#a53d8462179e4ca773d33843c15c77afc">More...</a><br /></td></tr>
<tr class="separator:a53d8462179e4ca773d33843c15c77afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplParams" colspan="2">template&lt;typename IntVec &gt; </td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8380e2ebec791f472a3634348bc0e22a">Invert</a> (const IntVec &amp;A, IntVec &amp;B, int n)</td></tr>
<tr class="memdesc:a8380e2ebec791f472a3634348bc0e22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the polynomial \(A_0 + A_1x^1 + \cdots+ A_nx^n\) into \(x^n - A_1x^{n-1} - \cdots- A_n\).  <a href="#a8380e2ebec791f472a3634348bc0e22a">More...</a><br /></td></tr>
<tr class="separator:a8380e2ebec791f472a3634348bc0e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplParams" colspan="2"><a id="a7022d363aa696d09b59c9499745466a6"></a>
template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7022d363aa696d09b59c9499745466a6">CalcNorm</a> (const Vect &amp;V, int n, Scal &amp;S, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a7022d363aa696d09b59c9499745466a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector \(V\), using components \([1..n]\), and puts the result in \(S\). <br /></td></tr>
<tr class="separator:a7022d363aa696d09b59c9499745466a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplParams" colspan="2"><a id="ada47b56ab96c49d7508b9379d0134472"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ada47b56ab96c49d7508b9379d0134472">CopyVect</a> (Vect &amp;A, const Vect &amp;B, int n)</td></tr>
<tr class="memdesc:ada47b56ab96c49d7508b9379d0134472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies vector \(B\) into vector \(A\) using components \([0..n-1]\). <br /></td></tr>
<tr class="separator:ada47b56ab96c49d7508b9379d0134472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplParams" colspan="2"><a id="ad43d2de9716e712790093eff2c12631f"></a>
template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">ModifVect</a> (Vect1 &amp;A, const Vect2 &amp;B, Scal x, int n)</td></tr>
<tr class="memdesc:ad43d2de9716e712790093eff2c12631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector \(B\) multiplied by \(x\) to vector \(A\) using components \([0..n-1]\), and puts the result in \(A\). <br /></td></tr>
<tr class="separator:ad43d2de9716e712790093eff2c12631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplParams" colspan="2"><a id="a127802e517a91268330bad9930e5a5f4"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a127802e517a91268330bad9930e5a5f4">ChangeSign</a> (Vect &amp;A, int n)</td></tr>
<tr class="memdesc:a127802e517a91268330bad9930e5a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign of the components \([0..n-1]\) of vector \(A\). <br /></td></tr>
<tr class="separator:a127802e517a91268330bad9930e5a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2df72413bf638fb96e4a4d0e078828"><td class="memItemLeft" align="right" valign="top"><a id="adf2df72413bf638fb96e4a4d0e078828"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#adf2df72413bf638fb96e4a4d0e078828">GCD2vect</a> (std::vector&lt; std::int64_t &gt; V, int k, int n)</td></tr>
<tr class="memdesc:adf2df72413bf638fb96e4a4d0e078828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of \(V[k],…,V[n-1]\). <br /></td></tr>
<tr class="separator:adf2df72413bf638fb96e4a4d0e078828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac21669d8af13d92327accdc26e9444ad">CreateMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:ac21669d8af13d92327accdc26e9444ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the square matrix \(A\) of dimensions \((d+1)\times(d+1)\).  <a href="#ac21669d8af13d92327accdc26e9444ad">More...</a><br /></td></tr>
<tr class="separator:ac21669d8af13d92327accdc26e9444ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplParams" colspan="2"><a id="a229c9368d745b9c4cae68c1b65e0e39c"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a229c9368d745b9c4cae68c1b65e0e39c">DeleteMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:a229c9368d745b9c4cae68c1b65e0e39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d\times d\) matrix \(A\). <br /></td></tr>
<tr class="separator:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#adfafd877b46442cc4b215448f25ccd7e">CreateMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:adfafd877b46442cc4b215448f25ccd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>).  <a href="#adfafd877b46442cc4b215448f25ccd7e">More...</a><br /></td></tr>
<tr class="separator:adfafd877b46442cc4b215448f25ccd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplParams" colspan="2"><a id="a0c884b60a0c4ee06455bf1c8e1819d35"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0c884b60a0c4ee06455bf1c8e1819d35">DeleteMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix \(A\). <br /></td></tr>
<tr class="separator:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplParams" colspan="2"><a id="a5af883014a948b37a49d69f729db70f1"></a>
template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a5af883014a948b37a49d69f729db70f1">CreateMatr</a> (IntMat &amp;A, int d)</td></tr>
<tr class="memdesc:a5af883014a948b37a49d69f729db70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the square matrix \(A\) of dimensions \(d\times d\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:a5af883014a948b37a49d69f729db70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a75474ce5f96fabf95eff6824df3d6f3d">CreateMatr</a> (IntMat &amp;A, int line, int col)</td></tr>
<tr class="memdesc:a75474ce5f96fabf95eff6824df3d6f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>).  <a href="#a75474ce5f96fabf95eff6824df3d6f3d">More...</a><br /></td></tr>
<tr class="separator:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2"><a id="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (IntMat &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the matrix \(A\). <br /></td></tr>
<tr class="separator:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aac81709c183b536ab80b83384314457f">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int n)</td></tr>
<tr class="memdesc:aac81709c183b536ab80b83384314457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above.  <a href="#aac81709c183b536ab80b83384314457f">More...</a><br /></td></tr>
<tr class="separator:aac81709c183b536ab80b83384314457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplParams" colspan="2"><a id="a8f32e22915b91e8c763f35b62c1039d9"></a>
template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8f32e22915b91e8c763f35b62c1039d9">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int line, int col)</td></tr>
<tr class="memdesc:a8f32e22915b91e8c763f35b62c1039d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above. <br /></td></tr>
<tr class="separator:a8f32e22915b91e8c763f35b62c1039d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplParams" colspan="2">template&lt;typename MatT &gt; </td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab1f9c94abf76e8ce25eb60bb6d1bda2e">toStr</a> (const MatT &amp;mat, int d1, int d2)</td></tr>
<tr class="memdesc:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms <code>mat</code> into a string.  <a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">More...</a><br /></td></tr>
<tr class="separator:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="memTemplParams" colspan="2"><a id="a88ebfbbde75cc3cb82fa92f688d338c6"></a>
template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a88ebfbbde75cc3cb82fa92f688d338c6">CheckTriangular</a> (const Matr &amp;A, int dim, const Int &amp;m)</td></tr>
<tr class="memdesc:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that square matrix \(A\) is upper triangular (modulo \(m\)) for dimensions 1 to <code>dim</code>. <br /></td></tr>
<tr class="separator:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa519a1e0589932719c79b73c76bb1093">Triangularization</a> (Matr &amp;W, Matr &amp;V, int lin, int col, const Int &amp;m)</td></tr>
<tr class="memdesc:aa519a1e0589932719c79b73c76bb1093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an integer triangularization operation modulo \(m\) on the matrix \(W\) to obtain an upper triangular matrix \(V\), dual to \(W\).  <a href="#aa519a1e0589932719c79b73c76bb1093">More...</a><br /></td></tr>
<tr class="separator:aa519a1e0589932719c79b73c76bb1093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a17df0e6fdb1f11335eaf91f82ee298b0">CalcDual</a> (const Matr &amp;A, Matr &amp;B, int d, const Int &amp;m)</td></tr>
<tr class="memdesc:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the \(m\)-dual of the matrix <code>A</code>.  <a href="#a17df0e6fdb1f11335eaf91f82ee298b0">More...</a><br /></td></tr>
<tr class="separator:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:a49105dd8e915243488440f570b3951bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a49105dd8e915243488440f570b3951bd">MyExit</a> (int status, std::string msg)</td></tr>
<tr class="memdesc:a49105dd8e915243488440f570b3951bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special exit function.  <a href="#a49105dd8e915243488440f570b3951bd">More...</a><br /></td></tr>
<tr class="separator:a49105dd8e915243488440f570b3951bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top"><a id="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac9adbd421a1148216c8eac1b7d96a5b8">MAX_LONG_DOUBLE</a> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\). <br /></td></tr>
<tr class="separator:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540464b3215755b9a0ba65ebfba38f8"><td class="memItemLeft" align="right" valign="top"><a id="ae540464b3215755b9a0ba65ebfba38f8"></a>
const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae540464b3215755b9a0ba65ebfba38f8">TWO_EXP</a> []</td></tr>
<tr class="memdesc:ae540464b3215755b9a0ba65ebfba38f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\). <br /></td></tr>
<tr class="separator:ae540464b3215755b9a0ba65ebfba38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lattice namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a951f7e7b03767aa0971dde55f9d328ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951f7e7b03767aa0971dde55f9d328ec">&#9670;&nbsp;</a></span>Weight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a951f7e7b03767aa0971dde55f9d328ec">LatticeTester::Weight</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar weight type. </p>
<dl class="section note"><dt>Note</dt><dd>We could have used <code>Weight</code>, but it might be wise to leave this <code>typedef</code> in case we decide to use <code>std::int64_t Weight</code> at some point. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&nbsp;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a> <code>PAL</code> is for the \(P_{\alpha}\) test. <br />
 <code>BAL</code> is for the bound on the \(P_{\alpha}\) test. <br />
 <code>NORMPAL</code> is for the \(P_{\alpha}\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. <br />
 <code>SEEKPAL</code> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>

</div>
</div>
<a id="a2cf3c4f4181718b7adc6f5e4513695a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3c4f4181718b7adc6f5e4513695a0">&#9670;&nbsp;</a></span>CriterionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">LatticeTester::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the merit criterion for ranking generators or lattices. </p>
<p><code>BEYER</code>: the figure of merit is the Beyer quotient \(Q_T\).<br />
 <code>SPECTRAL</code>: the figure of merit \(S_T\) is based on the spectral test.<br />
 <code>PALPHA</code>: the figure of merit is based on \(P_{\alpha}\).<br />
 <code>BOUND_JS</code>: the figure of merit is based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rSIN08a">[27]</a>&thinsp;. </p>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&nbsp;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\). </p>
<p><code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best lattice.<br />
 <code>LAMINATED</code>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br />
 <code>ROGERS</code>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br />
 <code>MINKOWSKI</code>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br />
 <code>MINKL1</code>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br />
 <code>PALPHA_N</code>: the case of the \(P_{\alpha}\) test.<br />
 <code>NORMA_GENERIC</code>: the trivial normalization (= 1) used for the generic case when no useful normalization constant is known. </p>

</div>
</div>
<a id="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which norm is used to measure the length of vectors. </p>
<p>For \(X = (x_1,…,x_t)\),</p>
<p><code>SUPNORM</code> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br />
 <code>L1NORM</code> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br />
 <code>L2NORM</code> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br />
 <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>

</div>
</div>
<a id="ad78f099c800f4c648134967a45b91058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f099c800f4c648134967a45b91058">&#9670;&nbsp;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">LatticeTester::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates in which form and where the results will be sent. </p>
<p><a class="anchor" id="REF__Const_co_output"></a> <code>TERMINAL</code>: the results will appear only on the terminal screen.<br />
 <code>RES</code>: the results will be in plain text format and sent to a file with extension <code>.res</code>.<br />
 <code>TEX</code>: the results will be in LaTeX format and sent to a file with extension <code>.tex</code>.<br />
<code>GEN</code>: the results will be sent to a file with extension <code>.gen</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7e699673c28800e0563b14a05392d1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e699673c28800e0563b14a05392d1c0">&#9670;&nbsp;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are: </p><p class="formulaDsp">
\begin{align*} B_0(x) &amp;= 1 \\ B_1(x) &amp;= x - 1/2 \\ B_2(x) &amp;= x^2-x+1/6 \\ B_3(x) &amp;= x^3 - 3x^2/2 + x/2 \\ B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\ B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6 \\ B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42 \\ B_7(x) &amp;= x^7 - 7x^6/2 + 7x^5/2 - 7x^3/6 + x/6 \\ B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30. \end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a17df0e6fdb1f11335eaf91f82ee298b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17df0e6fdb1f11335eaf91f82ee298b0">&#9670;&nbsp;</a></span>CalcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the \(m\)-dual of the matrix <code>A</code>. </p>
<p>The result is placed in the matrix <code>B</code>. Only the first \(d\) lines and columns are considered.</p>
<p>The vectors of the basis (lines of A) need to verify the properties (i), (ii) (iii), (iv) as described in the article: R. Couture and P L'Ecuyer, Orbits and lattices for linear random number generators with composite moduli, Mathematics of Computation, Volume 65, Number 213, bottom of page 199. </p>

</div>
</div>
<a id="aac81709c183b536ab80b83384314457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81709c183b536ab80b83384314457f">&#9670;&nbsp;</a></span>CopyMatr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As above. </p>
<p>Copies matrix \(B\) into matrix \(A\). </p>

</div>
</div>
<a id="ac21669d8af13d92327accdc26e9444ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21669d8af13d92327accdc26e9444ad">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the square matrix \(A\) of dimensions \((d+1)\times(d+1)\). </p>
<p>Initializes its elements to 0. </p>

</div>
</div>
<a id="adfafd877b46442cc4b215448f25ccd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfafd877b46442cc4b215448f25ccd7e">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>). </p>
<p>Initializes its elements to 0. </p>

</div>
</div>
<a id="a75474ce5f96fabf95eff6824df3d6f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75474ce5f96fabf95eff6824df3d6f3d">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>). </p>
<p>Initializes its elements to 0. </p>

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&nbsp;</a></span>Divide() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\). </p>
<p>Truncates \(q\) to the nearest integer towards 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). </p>

</div>
</div>
<a id="a96e86545bb8987e61e30693e09a60113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e86545bb8987e61e30693e09a60113">&#9670;&nbsp;</a></span>Divide() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0. </p>
<p>The remainder can be negative. One always has \(a = qb + r\) and \(|r| &lt; |b|\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="ab299b8335f9a690fad8b7838db6678ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab299b8335f9a690fad8b7838db6678ad">&#9670;&nbsp;</a></span>Divide() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0. </p>
<p>The remainder can be negative. One always has \(a = qb + r\) and \(|r| &lt; |b|\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="aa0315802d7f789ba576dbab54e9b7ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0315802d7f789ba576dbab54e9b7ebc">&#9670;&nbsp;</a></span>FigureOfMerit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FigureOfMerit </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>&#160;</td>
          <td class="paramname"><em>normalizerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code>BKZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code>DOUBLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute the Figure of Merit to a given matrix, according to a normalization criteria. </p>
<p>It first computes the shortest non-zero vector using the above functions. It then normalizes this value. Returns -1.0 if there was an error in Branch-and-Bound procedure while calculating the length of shortest non-zero vector. Return the figure of merit otherwise. </p>

</div>
</div>
<a id="aa15e63c629906c3f418221828a4fae37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15e63c629906c3f418221828a4fae37">&#9670;&nbsp;</a></span>FigureOfMeritBeyer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FigureOfMeritBeyer </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code>BKZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code>DOUBLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute the Figure of Merit to a given matrix, according to the Beyer criteria. </p>
<p>It first computes the Minkowski-reduced basis of the lattice and then makes the quotient of shortest over std::int64_test vector. Returns -1.0 if there was an error in Branch-and-Bound procedure while calculating the Minkowski-reduced basis. Return the figure of merit otherwise. </p>

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&nbsp;</a></span>FourierE1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. </p>
<p>Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a14db19d396c104b730dd5ea23a7752b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db19d396c104b730dd5ea23a7752b5">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::gcd </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the greatest common divisor of \(a\) and \(b\). </p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Il y a déjà des fonctions GCD dans <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>, pour les <code>std::int64_t</code> et les <code>ZZ</code> (voir fichier ZZ.h) </dd></dl>

</div>
</div>
<a id="a8380e2ebec791f472a3634348bc0e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8380e2ebec791f472a3634348bc0e22a">&#9670;&nbsp;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the polynomial \(A_0 + A_1x^1 + \cdots+ A_nx^n\) into \(x^n - A_1x^{n-1} - \cdots- A_n\). </p>
<p>The result is put in \(B\). </p>

</div>
</div>
<a id="aa671528908af203438e7969df2b35eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa671528908af203438e7969df2b35eae">&#9670;&nbsp;</a></span>MinkowskiReduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::MinkowskiReduction </td>
          <td>(</td>
          <td class="paramtype">BasIntMat &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code>BKZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code>DOUBLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reduces a basis to a Minkowski-reduced basis. </p>
<p>Such basis has strong properties regarding the length of its vectors but will require a huge running time, especially when the dimension of the basis increases. Such Minkowski-reduced basis is usefull, for example, to calculate a Beyer quotient (as implemented in <a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa0315802d7f789ba576dbab54e9b7ebc" title="This function compute the Figure of Merit to a given matrix, according to a normalization criteria...">FigureOfMerit()</a>). </p>

</div>
</div>
<a id="ab3fd3ae7e7a02590cc97b3f3f28e0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fd3ae7e7a02590cc97b3f3f28e0638">&#9670;&nbsp;</a></span>Modulo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the "positive" remainder \(r = a \bmod b\), i.e. </p>
<p>such that \(0 \le r &lt; b\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="c bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="c bl br">2 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="c bl br">\(1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a37596db3ece874abb24b32cab2873e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37596db3ece874abb24b32cab2873e33">&#9670;&nbsp;</a></span>Modulo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the "positive" remainder \(r = a \bmod b\), i.e. </p>
<p>such that \(0 \le r &lt; b\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="c bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="c bl br">2 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="c bl br">\(1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a49105dd8e915243488440f570b3951bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49105dd8e915243488440f570b3951bd">&#9670;&nbsp;</a></span>MyExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::MyExit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special exit function. </p>
<p><code>status</code> is the status code to return to the system, <code>msg</code> is the message to print upon exit. </p>

</div>
</div>
<a id="abf71d740b6bd3ef605406a4493939692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf71d740b6bd3ef605406a4493939692">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code></code>(first,second). </p>

</div>
</div>
<a id="a0f1e552bdaa65b87d6fd17c57edb040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1e552bdaa65b87d6fd17c57edb040e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a id="a53d8462179e4ca773d33843c15c77afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d8462179e4ca773d33843c15c77afc">&#9670;&nbsp;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const Vect1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors \(A\) and \(B\), using components \([0..n-1]\), and puts the result in \(D\). </p>
<p>THIS DOES NOT SEEM TO BE A VERY SAFE IMPLEMENTATION </p>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&nbsp;</a></span>Quotient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(q = a/b\) by dropping the fractionnal part, i.e. </p>
<p>truncates towards 0. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="aa7c40ca56dbbbaeeae0b5ab38ac83de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c40ca56dbbbaeeae0b5ab38ac83de1">&#9670;&nbsp;</a></span>Quotient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(q = a/b\) by dropping the fractionnal part, i.e. </p>
<p>truncates towards 0. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a8e829d77e42c8dbabc8f6e37eca2a714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e829d77e42c8dbabc8f6e37eca2a714">&#9670;&nbsp;</a></span>RandInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random integer in \([i, j]\). </p>
<p>Numbers \(i\) and \(j\) can occur. Restriction: \(i &lt; j\). </p>

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&nbsp;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number has 53 random bits. </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&nbsp;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>If not called, a default seed will be used. </p>

</div>
</div>
<a id="a14ffc84b470dfb03f7105b232cec39a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ffc84b470dfb03f7105b232cec39a1">&#9670;&nbsp;</a></span>ShortestVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntMat , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::ShortestVector </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code>BKZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code>DOUBLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows computation of the shortest non-zero vector in a lattice, according to the selected norm. </p>
<p>Many parameters can bet set by the user, otherwise the function work with default values. Returns -1.0 if there was an error in Branch-and-Bound procedure. Return the length of the shortest non-zero vector otherwise. </p>

</div>
</div>
<a id="ac57f48ff79454c1d449bc309bebdcbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f48ff79454c1d449bc309bebdcbdc">&#9670;&nbsp;</a></span>SqrRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::SqrRoot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(\sqrt{x}\). </p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Cette fonction est-elle encore utilisée? </dd></dl>

</div>
</div>
<a id="ab1f9c94abf76e8ce25eb60bb6d1bda2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">&#9670;&nbsp;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms <code>mat</code> into a string. </p>
<p>Prints the first \(d1\) rows and \(d2\) columns. Indices start at 1. Elements with index 0 are not printed. </p>

</div>
</div>
<a id="ac0ab3cd721290c62bbed850fac763aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ab3cd721290c62bbed850fac763aa9">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints components \([c..d-1]\) of vector \(A\) as a string. </p>
<p>Components are separated by string <code>sep</code>. </p>

</div>
</div>
<a id="aa519a1e0589932719c79b73c76bb1093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa519a1e0589932719c79b73c76bb1093">&#9670;&nbsp;</a></span>Triangularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Triangularization </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an integer triangularization operation modulo \(m\) on the matrix \(W\) to obtain an upper triangular matrix \(V\), dual to \(W\). </p>
<p>However, the matrix \(W\) will be transformed too in order to preserve duality. Only the first <code>lin</code> lines and the first <code>col</code> columns of the matrices will be considered. The main idea is to transform a generating family of vectors into a basis (removing from the family the vectors that are linear combination of other vectors).</p>
<p>Refer to the article: R. Couture and P L'Ecuyer, Orbits and lattices for linear random number generators with composite moduli, Mathematics of Computation, Volume 65, Number 213, bottom of page 199. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated on Mon Jul 30 2018 16:10:36 for Lattice Tester Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
