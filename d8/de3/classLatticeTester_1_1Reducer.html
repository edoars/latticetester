<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Manual: LatticeTester::Reducer&lt; Int, BasInt, Dbl, RedDbl &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Manual
   &#160;<span id="projectnumber">0.1.0-templates-24</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/de3/classLatticeTester_1_1Reducer.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../d4/d16/classLatticeTester_1_1Reducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LatticeTester::Reducer&lt; Int, BasInt, Dbl, RedDbl &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements (or wraps from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>) all the functions that are needed to reduce a basis.  
 <a href="../../d8/de3/classLatticeTester_1_1Reducer.html#details">More...</a></p>

<p><code>#include &lt;latticetester/Reducer.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86a400ff9d403eecb6a5efb9b305ffdb"><td class="memItemLeft" align="right" valign="top"><a id="a86a400ff9d403eecb6a5efb9b305ffdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a86a400ff9d403eecb6a5efb9b305ffdb">Reducer</a> (<a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a>&lt; Int, BasInt, Dbl, RedDbl &gt; &amp;lat)</td></tr>
<tr class="memdesc:a86a400ff9d403eecb6a5efb9b305ffdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initializes the reducer to work on lattice basis <code>lat</code>. <br /></td></tr>
<tr class="separator:a86a400ff9d403eecb6a5efb9b305ffdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1b607954fc6e40fdb06ff36eb7f837"><td class="memItemLeft" align="right" valign="top"><a id="a0e1b607954fc6e40fdb06ff36eb7f837"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a0e1b607954fc6e40fdb06ff36eb7f837">Reducer</a> (const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt; &amp;red)</td></tr>
<tr class="memdesc:a0e1b607954fc6e40fdb06ff36eb7f837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a0e1b607954fc6e40fdb06ff36eb7f837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeba49aab1f7b02a5fcca7e78c9f82d2"><td class="memItemLeft" align="right" valign="top"><a id="abeba49aab1f7b02a5fcca7e78c9f82d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#abeba49aab1f7b02a5fcca7e78c9f82d2">~Reducer</a> ()</td></tr>
<tr class="memdesc:abeba49aab1f7b02a5fcca7e78c9f82d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:abeba49aab1f7b02a5fcca7e78c9f82d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e18d05dd79ddb092c836b1bfd4ed99"><td class="memItemLeft" align="right" valign="top"><a id="a92e18d05dd79ddb092c836b1bfd4ed99"></a>
<a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a92e18d05dd79ddb092c836b1bfd4ed99">operator=</a> (const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt; &amp;red)</td></tr>
<tr class="memdesc:a92e18d05dd79ddb092c836b1bfd4ed99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that allows copying <code>red</code> into the object by usig copy. <br /></td></tr>
<tr class="separator:a92e18d05dd79ddb092c836b1bfd4ed99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01781986162b073744e94b37c3c200cd"><td class="memItemLeft" align="right" valign="top"><a id="a01781986162b073744e94b37c3c200cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a01781986162b073744e94b37c3c200cd">copy</a> (const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt; &amp;red)</td></tr>
<tr class="memdesc:a01781986162b073744e94b37c3c200cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the reducer <code>red</code> into this object. <br /></td></tr>
<tr class="separator:a01781986162b073744e94b37c3c200cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b907a63eadf3cda2839a3865883e68f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6b907a63eadf3cda2839a3865883e68f">shortestVector</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a6b907a63eadf3cda2839a3865883e68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shortest non-zero vector of the <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html" title="This class represents a lattice and its basis and offers tools to do basic manipulations on lattice b...">IntLatticeBasis</a> stored in this object with respect to norm <code>norm</code> using branch-and-bound and the algorithm described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[13]</a>.  <a href="#a6b907a63eadf3cda2839a3865883e68f">More...</a><br /></td></tr>
<tr class="separator:a6b907a63eadf3cda2839a3865883e68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5b086ba333d80df55920936cad5a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a9a5b086ba333d80df55920936cad5a7e">preRedDieter</a> (int d)</td></tr>
<tr class="memdesc:a9a5b086ba333d80df55920936cad5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible.  <a href="#a9a5b086ba333d80df55920936cad5a7e">More...</a><br /></td></tr>
<tr class="separator:a9a5b086ba333d80df55920936cad5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129f97f6a2c464e4dbdd900753ba49f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a129f97f6a2c464e4dbdd900753ba49f4">preRedDieterRandomized</a> (int d, int seed)</td></tr>
<tr class="memdesc:a129f97f6a2c464e4dbdd900753ba49f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible.  <a href="#a129f97f6a2c464e4dbdd900753ba49f4">More...</a><br /></td></tr>
<tr class="separator:a129f97f6a2c464e4dbdd900753ba49f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ca17f09eee1f34935eef8ca0e515a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a538ca17f09eee1f34935eef8ca0e515a">redDieter</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a538ca17f09eee1f34935eef8ca0e515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest non-zero vector using norm <code>norm</code>.  <a href="#a538ca17f09eee1f34935eef8ca0e515a">More...</a><br /></td></tr>
<tr class="separator:a538ca17f09eee1f34935eef8ca0e515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5517bc4d39ecadd50a4b0fc3086443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a1d5517bc4d39ecadd50a4b0fc3086443">redLLL</a> (double fact, std::int64_t maxcpt, int dim)</td></tr>
<tr class="memdesc:a1d5517bc4d39ecadd50a4b0fc3086443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than.  <a href="#a1d5517bc4d39ecadd50a4b0fc3086443">More...</a><br /></td></tr>
<tr class="separator:a1d5517bc4d39ecadd50a4b0fc3086443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0792ad9a42d12dd69248c0e20b4544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a9c0792ad9a42d12dd69248c0e20b4544">redLLLNTL</a> (double fact=0.999999, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> precision=QUADRUPLE, int dim=0)</td></tr>
<tr class="memdesc:a9c0792ad9a42d12dd69248c0e20b4544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than.  <a href="#a9c0792ad9a42d12dd69248c0e20b4544">More...</a><br /></td></tr>
<tr class="separator:a9c0792ad9a42d12dd69248c0e20b4544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935c4f896a9187132dc1b4da22a62108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a935c4f896a9187132dc1b4da22a62108">redLLLNTLExact</a> (double fact)</td></tr>
<tr class="memdesc:a935c4f896a9187132dc1b4da22a62108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than.  <a href="#a935c4f896a9187132dc1b4da22a62108">More...</a><br /></td></tr>
<tr class="separator:a935c4f896a9187132dc1b4da22a62108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3976273ae6a66d009ac9a14625d016c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ad3976273ae6a66d009ac9a14625d016c">redBKZ</a> (double fact=0.999999, std::int64_t blocksize=10, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> precision=QUADRUPLE, int dim=0)</td></tr>
<tr class="memdesc:ad3976273ae6a66d009ac9a14625d016c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the BKZ (Block-Korkine-Zolotarev) basis reduction with the the coefficient <code>fact</code> and a block size <code>Blocksize</code>.  <a href="#ad3976273ae6a66d009ac9a14625d016c">More...</a><br /></td></tr>
<tr class="separator:ad3976273ae6a66d009ac9a14625d016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb99bbb4d5945d278572f35a638f8c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aaeb99bbb4d5945d278572f35a638f8c9">reductMinkowski</a> (int d)</td></tr>
<tr class="memdesc:aaeb99bbb4d5945d278572f35a638f8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the current basis to a Minkowski reduced basis with respect to the Euclidean norm, assuming that the first \(d\) vectors are already reduced and sorted.  <a href="#aaeb99bbb4d5945d278572f35a638f8c9">More...</a><br /></td></tr>
<tr class="separator:aaeb99bbb4d5945d278572f35a638f8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98bc6c4c0180cc1f9d451d61f289d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aa98bc6c4c0180cc1f9d451d61f289d57">pairwiseRedPrimal</a> (int i, int d)</td></tr>
<tr class="memdesc:aa98bc6c4c0180cc1f9d451d61f289d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pairwise reductions.  <a href="#aa98bc6c4c0180cc1f9d451d61f289d57">More...</a><br /></td></tr>
<tr class="separator:aa98bc6c4c0180cc1f9d451d61f289d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa588accfaf34f85bbd5bbe5a60a69c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aa588accfaf34f85bbd5bbe5a60a69c51">pairwiseRedDual</a> (int i)</td></tr>
<tr class="memdesc:aa588accfaf34f85bbd5bbe5a60a69c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pairwise reductions, trying to reduce every other vector of the <em>dual</em> basis by adding multiples of the \(i\)-th vector.  <a href="#aa588accfaf34f85bbd5bbe5a60a69c51">More...</a><br /></td></tr>
<tr class="separator:aa588accfaf34f85bbd5bbe5a60a69c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb5c4adb586ba0a805ab0a570ba7cee"><td class="memItemLeft" align="right" valign="top"><a id="aabb5c4adb586ba0a805ab0a570ba7cee"></a>
Dbl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aabb5c4adb586ba0a805ab0a570ba7cee">getMinLength</a> ()</td></tr>
<tr class="memdesc:aabb5c4adb586ba0a805ab0a570ba7cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the shortest basis vector in the lattice. <br /></td></tr>
<tr class="separator:aabb5c4adb586ba0a805ab0a570ba7cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1428587e47787b13b68a9b5a843cc090"><td class="memItemLeft" align="right" valign="top">Dbl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a1428587e47787b13b68a9b5a843cc090">getMaxLength</a> ()</td></tr>
<tr class="memdesc:a1428587e47787b13b68a9b5a843cc090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the std::int64_test basis vector in the lattice.  <a href="#a1428587e47787b13b68a9b5a843cc090">More...</a><br /></td></tr>
<tr class="separator:a1428587e47787b13b68a9b5a843cc090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20dd87ca85cf906e59d430c6a16bada"><td class="memItemLeft" align="right" valign="top"><a id="ad20dd87ca85cf906e59d430c6a16bada"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ad20dd87ca85cf906e59d430c6a16bada">setBoundL2</a> (const <a class="el" href="../../d0/d01/classNTL_1_1vector.html">DblVec</a> &amp;V, int dim1, int dim2)</td></tr>
<tr class="memdesc:ad20dd87ca85cf906e59d430c6a16bada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower bound on the square length of the shortest vector in dimension \(i\) to \(V[i]\), for \(i\) going from <code>dim1</code> to <code>dim2</code>. <br /></td></tr>
<tr class="separator:ad20dd87ca85cf906e59d430c6a16bada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eae81a4e715c955faf89364495ca15"><td class="memItemLeft" align="right" valign="top"><a id="ad9eae81a4e715c955faf89364495ca15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ad9eae81a4e715c955faf89364495ca15">trace</a> (char *mess)</td></tr>
<tr class="memdesc:ad9eae81a4e715c955faf89364495ca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug function that print the primal and dual bases. <br /></td></tr>
<tr class="separator:ad9eae81a4e715c955faf89364495ca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aaa22d19b9ee0d71ca7e174e15d776073"><td class="memItemLeft" align="right" valign="top">static std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aaa22d19b9ee0d71ca7e174e15d776073">maxNodesBB</a> = 10000000</td></tr>
<tr class="memdesc:aaa22d19b9ee0d71ca7e174e15d776073"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of nodes in the branch-and-bound tree when calling <code>ShortestVector</code> or <code>reductMinkowski</code>.  <a href="#aaa22d19b9ee0d71ca7e174e15d776073">More...</a><br /></td></tr>
<tr class="separator:aaa22d19b9ee0d71ca7e174e15d776073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pre-reduction flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These boolean variables indicate which type of pre-reduction is to be performed for <code>ShortestVector</code> (SV) and for <code>reductMinkowski</code> (RM).</p>
<p><code>Dieter</code> means the pairwise pre-reduction as in the method <code>PreRedDieter</code>. <code>LLL</code> means the LLL reduction of Lenstra, Lenstra, and Lovász. The variable <code>PreRedDieterSV</code> is originally set to <code>true</code> and the two others are originally set to <code>false</code>. These variables are reset automatically depending on the thresholds <code>MinkLLL, ShortDiet, ShortLLL</code> as explained above. </p>
</div></td></tr>
<tr class="memitem:ac0f0ead52a364ac804f9769769bc9ce1"><td class="memItemLeft" align="right" valign="top"><a id="ac0f0ead52a364ac804f9769769bc9ce1"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedDieterSV</b> = false</td></tr>
<tr class="separator:ac0f0ead52a364ac804f9769769bc9ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7186d064468a1e88a74de9dc2dd2856a"><td class="memItemLeft" align="right" valign="top"><a id="a7186d064468a1e88a74de9dc2dd2856a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedLLLSV</b> = false</td></tr>
<tr class="separator:a7186d064468a1e88a74de9dc2dd2856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e945bdd08f99571d832c9e1d04f98f"><td class="memItemLeft" align="right" valign="top"><a id="a35e945bdd08f99571d832c9e1d04f98f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedLLLRM</b> = false</td></tr>
<tr class="separator:a35e945bdd08f99571d832c9e1d04f98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed0aaca5be8e1fc20b18bb115471142"><td class="memItemLeft" align="right" valign="top"><a id="a3ed0aaca5be8e1fc20b18bb115471142"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedBKZ</b> = true</td></tr>
<tr class="separator:a3ed0aaca5be8e1fc20b18bb115471142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Int, typename BasInt, typename Dbl, typename RedDbl&gt;<br />
class LatticeTester::Reducer&lt; Int, BasInt, Dbl, RedDbl &gt;</h3>

<p>This class implements (or wraps from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>) all the functions that are needed to reduce a basis. </p>
<p>For a given lattice basis, stored in an <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html" title="This class represents a lattice and its basis and offers tools to do basic manipulations on lattice b...">IntLatticeBasis</a>, this class can reduce it in the sense of Minkowski, as well as find the shortest vector in the lattice with the Branch-and-Bound algorithm. It is also possible to use weaker, but much faster, reductions such as Dieter reduction <a class="el" href="../../d0/de3/citelist.html#CITEREF_rDIE75a">[4]</a>, LLL reduction <a class="el" href="../../d0/de3/citelist.html#CITEREF_mLEN82a">[20]</a> and BKZ reduction <a class="el" href="../../d0/de3/citelist.html#CITEREF_mSCH91a">[25]</a>. The theoretical details of these algorithm are presented in <a class="el" href="../../da/d18/a_intro.html">Background</a>.</p>
<p>The LLL reduction has been implemented both by us and in <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>, but since we did not test our algorithm for efficiency, it is recommended to stick with the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> implementation wrapped by the methods redLLLNTL and redLLLNTLExact. Note that redBKZ is also a wrapper for <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> algorithm for BKZ reduction.</p>
<p>For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and to find the shortest non-zero vector of the lattice using pre-reductions and a branch-and-bound (BB) algorithm <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[13]</a>&thinsp;. It also implements the method of Lenstra, Lenstra and Lovasz (LLL) <a class="el" href="../../d0/de3/citelist.html#CITEREF_mLEN82a">[20]</a>&thinsp; as well as the method of Dieter <a class="el" href="../../d0/de3/citelist.html#CITEREF_rDIE75a">[4]</a>&thinsp; to reduce a lattice basis. The Minkowski, LLL and Branch-and-bound Reduction do not need the dual lattice. Nonetheless, if a <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html" title="This class represents a lattice and its basis and offers tools to do basic manipulations on lattice b...">IntLatticeBasis</a> object with a true with-dual flag is given to a <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html" title="This class implements (or wraps from NTL) all the functions that are needed to reduce a basis...">Reducer</a>, the duality will be preserve during reduction. Beside, the algorithm BKZ implemented in the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> Library can be used as a prereduction before the Branch-and-Bound.</p>
<p><b>USAGE DESCRIPTION</b> <code>shortestVector</code> no pre-red </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1428587e47787b13b68a9b5a843cc090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1428587e47787b13b68a9b5a843cc090">&#9670;&nbsp;</a></span>getMaxLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dbl <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::getMaxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the std::int64_test basis vector in the lattice. </p>
<p>Used in Beyer Test. </p>

</div>
</div>
<a id="aa588accfaf34f85bbd5bbe5a60a69c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa588accfaf34f85bbd5bbe5a60a69c51">&#9670;&nbsp;</a></span>pairwiseRedDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::pairwiseRedDual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pairwise reductions, trying to reduce every other vector of the <em>dual</em> basis by adding multiples of the \(i\)-th vector. </p>
<p>That may change the \(i\)-th vector in the primal basis. Each such dual reduction is actually performed only if that does not increase the length of vector \(i\) in the primal basis. Always uses the Euclidean norm. </p>

</div>
</div>
<a id="aa98bc6c4c0180cc1f9d451d61f289d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98bc6c4c0180cc1f9d451d61f289d57">&#9670;&nbsp;</a></span>pairwiseRedPrimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::pairwiseRedPrimal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pairwise reductions. </p>
<p>This method tries to reduce each basis vector with index larger than \(d\) and distinct from \(i\) by adding to it a multiple of the \(i\)-th vector. Always uses the Euclidean norm. </p>

</div>
</div>
<a id="a9a5b086ba333d80df55920936cad5a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5b086ba333d80df55920936cad5a7e">&#9670;&nbsp;</a></span>preRedDieter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::preRedDieter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible. </p>
<p>Always use the Euclidean norm. </p>

</div>
</div>
<a id="a129f97f6a2c464e4dbdd900753ba49f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129f97f6a2c464e4dbdd900753ba49f4">&#9670;&nbsp;</a></span>preRedDieterRandomized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::preRedDieterRandomized </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible. </p>
<p>Always use the Euclidean norm. The choice of i is randomized. </p>

</div>
</div>
<a id="ad3976273ae6a66d009ac9a14625d016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3976273ae6a66d009ac9a14625d016c">&#9670;&nbsp;</a></span>redBKZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::redBKZ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>QUADRUPLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the BKZ (Block-Korkine-Zolotarev) basis reduction with the the coefficient <code>fact</code> and a block size <code>Blocksize</code>. </p>
<p>The precision can be given. See <a class="el" href="../../db/da7/Const_8h.html" title="This module contains global constants used in LatticeTester. ">Const.h</a> for further information. </p>

</div>
</div>
<a id="a538ca17f09eee1f34935eef8ca0e515a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538ca17f09eee1f34935eef8ca0e515a">&#9670;&nbsp;</a></span>redDieter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::redDieter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the shortest non-zero vector using norm <code>norm</code>. </p>
<p>Returns <code>true</code> upon success. Uses the algorithm of Dieter <a class="el" href="../../d0/de3/citelist.html#CITEREF_rDIE75a">[4]</a>&thinsp; given in Knuth <a class="el" href="../../d0/de3/citelist.html#CITEREF_rKNU98a">[12]</a>&thinsp;. </p>

</div>
</div>
<a id="a1d5517bc4d39ecadd50a4b0fc3086443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5517bc4d39ecadd50a4b0fc3086443">&#9670;&nbsp;</a></span>redLLL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::redLLL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>maxcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than. </p>
<ol type="1">
<li>If <code>fact</code> is closer to 1, the basis will be (typically) "more
reduced", but that will require more work. The reduction algorithm is applied until <code>maxcpt</code> successful transformations have been done. Always uses the Euclidean norm. </li>
</ol>

</div>
</div>
<a id="a9c0792ad9a42d12dd69248c0e20b4544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0792ad9a42d12dd69248c0e20b4544">&#9670;&nbsp;</a></span>redLLLNTL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::redLLLNTL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>QUADRUPLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than. </p>
<ol type="1">
<li>If <code>fact</code> is closer to 1, the basis will be (typically) "more
reduced", but that will require more work. The reduction algorithm is applied until <code>maxcpt</code> successful transformations have been done. Always uses the Euclidean norm. This version is implemented in the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> Library with approximate number with arbitrary precision. The precision can be given. See <a class="el" href="../../db/da7/Const_8h.html" title="This module contains global constants used in LatticeTester. ">Const.h</a> for further information. </li>
</ol>

</div>
</div>
<a id="a935c4f896a9187132dc1b4da22a62108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935c4f896a9187132dc1b4da22a62108">&#9670;&nbsp;</a></span>redLLLNTLExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::redLLLNTLExact </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than. </p>
<ol type="1">
<li>If <code>fact</code> is closer to 1, the basis will be (typically) "more
reduced", but that will require more work. The reduction algorithm is applied until <code>maxcpt</code> successful transformations have been done. Always uses the Euclidean norm. This version is implemented in the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> Library with exact number (arbitrary precision RR) </li>
</ol>

</div>
</div>
<a id="aaeb99bbb4d5945d278572f35a638f8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb99bbb4d5945d278572f35a638f8c9">&#9670;&nbsp;</a></span>reductMinkowski()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::reductMinkowski </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the current basis to a Minkowski reduced basis with respect to the Euclidean norm, assuming that the first \(d\) vectors are already reduced and sorted. </p>
<p>If <code>MaxNodesBB</code> is exceeded during one of the branch-and-bound step, the method aborts and returns <code>false</code>. Otherwise it returns <code>true</code>, the basis is reduced and sorted by vector lengths (the shortest vector is <code>V[0]</code> and the std::int64_test is <code>V[Dim-1]</code>). </p>

</div>
</div>
<a id="a6b907a63eadf3cda2839a3865883e68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b907a63eadf3cda2839a3865883e68f">&#9670;&nbsp;</a></span>shortestVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::shortestVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the shortest non-zero vector of the <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html" title="This class represents a lattice and its basis and offers tools to do basic manipulations on lattice b...">IntLatticeBasis</a> stored in this object with respect to norm <code>norm</code> using branch-and-bound and the algorithm described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[13]</a>. </p>
<p>The <code>Norm</code> member of this object will be changed to <code>norm</code>. If <code>MaxNodesBB</code> is exceeded during one of the branch-and-bounds, the method aborts and returns <code>false</code>. Otherwise, it returns <code>true</code>. If the reduction was successful, the new reduced basis can be accessed as desired via getIntLatticeBasis().</p>
<p>It is strongly recommended to use some kind of pre-reduction before using this method. We suggest redLLLNTL that should be god for most use cases, but redBKZ can sometimes git better results. None of the Dieter pre-reduction should be called before calling this, unless the user's intention is to benchmark the different methods in his use case. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaa22d19b9ee0d71ca7e174e15d776073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa22d19b9ee0d71ca7e174e15d776073">&#9670;&nbsp;</a></span>maxNodesBB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename Dbl , typename RedDbl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, Dbl, RedDbl &gt;::maxNodesBB = 10000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of nodes in the branch-and-bound tree when calling <code>ShortestVector</code> or <code>reductMinkowski</code>. </p>
<p>When this number is exceeded, the method aborts and returns <code>false</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/latticetester/Reducer.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li><li class="navelem"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a></li>
    <li class="footer">Generated on Mon Jul 30 2018 16:10:36 for Lattice Tester Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
