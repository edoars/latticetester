<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Manual: LatticeTester Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Manual
   &#160;<span id="projectnumber">0.1.0-doc-120</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a> Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>User's guide</h1>
<p>This is the reference manual of <a href="https://github.com/umontreal-simul/latticetester">LatticeTester</a>, a library intented to simplify the construction of software studying lattices.</p>
<h3>Manual Outline</h3>
<p>The manual includes the following sections</p><ul>
<li>This introduction page, describing the capabilities of <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em></li>
<li><a class="el" href="df/d1d/examples_page.html">Examples</a> that every beginner should look at to familiarize itself with usage of the main classes of the library</li>
<li><a class="el" href="da/d18/a_intro.html">Background</a> presenting the unknowledgeable user with enough theoretical background to get started</li>
<li><a class="el" href="d4/d4e/detailed_usage.html">Detailed usage instructions</a> presenting the installation process (the dependencies and the compilation process) and the usage of an executable bundled with <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> to perform high-level use of the library.</li>
</ul>
<p>This manual also include a full API documentation automatically generated by Doxygen. It is available through the "Classes" and "Namespaces" buttons above. Finally, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> is open source software distributed with a licence available on <a href="https://github.com/umontreal-simul/latticetester">Github</a>.</p>
<h1>Overview</h1>
<p><em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> is a C++ library to perform various computations on lattices \(L_t\) in the \(t\)-dimensional rational space. Lattices are discrete subgroups of a vector space (generally, the set of all integer combinations of a basis of said vector space) encountered, as an example, in the analysis of quasi-Monte Carlo point sets and certain kinds of pseudo-random number generators.</p>
<p><em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> can perform most of its operations either on the <b>lattice</b> spanned by \(v_1, \ldots, v_s \in \mathbb{Q}^t\), \(L_t = \{\sum_{i=1}^s a_i v_i \ | \ a_i \in \mathbb{Z}\}\), or its <b>m-dual lattice</b>, \(mL_t^* = \{w \ | \ w \cdot v \in m\mathbb{Z}, \ \forall v \in L_t\}\). To do so, lattices are stored as a <b>basis</b>, a minimal (of cardinality \(t\) set of generating vectors \(\{v_1, \ldots, v_t\} \in L_t\), rescalled to only have integer coordinates. Vectors are stored as integer so that all the computations are done exactly on the lattice. <b><em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> only accepts integer lattices and lattices need to be rescalled before being given as input.</b> Note that \(mL_t^*\) is also stored as integer vectors. In fact, \(m\) is choosen so that \(L_t^* \subset \mathbb{Q}^t\) becomes \(mL_t^* \subset\mathbb{Z}^t\).</p>
<p>The main goal of this library is to implements and/or facilitate the computation of theoretical measure of uniformity (or figures of merit) on lattices, as it is the main concern when studying pseudo-random point sets <a class="el" href="d0/de3/citelist.html#CITEREF_rKNU81a">[11]</a><a class="el" href="d0/de3/citelist.html#CITEREF_rNIE92b">[21]</a>. To perform these algorithms efficiently, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> also implements a handfull of handy lattices manipulations:</p><ol type="1">
<li><b>Lattice Basis Construction</b>: Given a set of vectors that are not necessarily independent but span a lattice, find a basis for that lattice.</li>
<li><b>Dual Lattice Basis construction</b>: Given a lattice basis for \(L_t\), compute the corresponding m-dual lattice basis for \(mL_t^*\) whether \(m\) is known or not.</li>
<li><b>Lattice Basis Reduction</b>: Given a lattice basis, find another basis whose vectors are nearly orthogonal or as short as possible. There are many variants and definitions for this, such as the well known LLL reduction which is available.</li>
<li><b>Shortest Vector computation</b>: Find the shortest non-zero vector in a lattice, and prove it is the shortest.</li>
</ol>
<p>The measures of uniformity that are considered by this software are the spectral test, that is the inverse length of the shortest vector in the dual lattie, and the Beyer ratio, which is an old test (<a class="el" href="d0/de3/citelist.html#CITEREF_rBEY71a">[3]</a>) inlcuded mainly as part of our legacy code base. Building on those mesures of uniformity, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> also implements classes to build <b>figures of merit</b> upon them. Figures of merit are a recurring theme in quasi-Monte Carlo point set studies <a class="el" href="d0/de3/citelist.html#CITEREF_vLEC12a">[14]</a>. A figure of merit is a standardized measure that can be used to compare point sets between them. Generally, they are constructed as a weighted sum, or the minimum of weighted values : </p><p class="formulaDsp">
\[ \min_{i \subset I} \omega_i \ell_i \]
</p>
<p> with \(I\), a set of indices, \(\omega_i\) being weights and \(\ell_i\) a mesure on the projection of a lattice on set of indices \(i\).</p>
<p>Finaly, for the sake of convenience, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> also features a high-level executable that can perform, without much flexibility, some of the computations featured in <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>. Its usage is described in <a class="el" href="d4/d4e/detailed_usage.html">Detailed usage instructions</a></p>
<p><em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> is not intended as a tool to search for lattices that conform to certain prerequisites, but instead it can be extended with a few classes to do so. <b><a href="https://github.com/umontreal-simul/latnetbuilder">LatNet Builder</a></b> and <b><a href="https://github.com/umontreal-simul/latmrg">LatMRG</a></b> are software tools designed in our laboratory that are examples of the capabilities of this library. The first one is designed to analyze and search for lattice rules for quasi-Monte-Carlo integration whilst the second does something similar for linear congruential pseudo-random number generators.</p>
<p>In the next section, you will find a detailled list of what is implemented in <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>, along with links to the relevant parts of the API documentation. Users wishing to quickly "get their hands dirty" in this library are advised to skip the next section and to go to the <a class="el" href="df/d1d/examples_page.html">Examples</a>.</p>
<h1>Contents and implementation</h1>
<p>This project is mostly built as an object oriented library. The following describes the contents of the library and gives the names of the classes performing them. This is essentially a lenghtier version of the section above containing "from the ground up" explanations of the library contents, starting from lattice representation and going to the construction of basic figures of merit. While goind through the functionnalities of <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> this section will also mention every tool needed to access these functions.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This section assumes the reader is familiar with a bit of lattice specific vocabulary. We have two options (I prefer the second one):<ul>
<li>Have explanations here of every thing mentionned and keep <a class="el" href="da/d18/a_intro.html">Background</a> as a more advanced ressource</li>
<li>Only use <a class="el" href="da/d18/a_intro.html">Background</a> as our only theorethical guide.</li>
</ul>
</dd></dl>
<h2>Types and representations</h2>
<p>Before diving into the features of <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> lets look at what are NOT features of this library, but are needed by it: the ability to manipulate numbers of arbitrary size with decent efficiency. To do that, we use another library called the Number Theory Library, more commonly called <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL.">NTL</a>. Anyone using <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> will need to use some of the functionnalities of <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL.">NTL</a> at one point. Many basic mathematical functions require using this library directly. Its documentation can be found at <a href="https://www.shoup.net/ntl/">https://www.shoup.net/ntl/</a>. Note that this documentation also contains a namespace called <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL.">NTL</a>. This namespace contains extentions of <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL.">NTL</a> functions to non-NTL types to ease the usage of <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> with <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL.">NTL</a> and non-NTL types with the same code.</p>
<p>As its name says, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> is a library to manipulate lattices. As such, it implements classes representing lattices. First there is the <code>IntLatticeBasis</code> class that simply is a class to represent a lattice basis by storing a matrix. This class can exchange the order of the vectors in the basis, compute their norm and also store the dual basis. Most functions doing computations on lattices directly use either the basis matrix or this class. it is recommended to use this class to represent lattices when working exclusively with <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>. This is what is done in the <a class="el" href="df/d1d/examples_page.html">Examples</a>.</p>
<p>When using the library with a specific problem in mind, more powerful objects representing lattices can be obtained by using the problem structure to build a lattice and different projections easily. For this use case, we provide the <code>IntLattice</code> class. This class inherits <code>IntLatticeBasis</code> to be used with the library easily and contains lattice specific features and virtual methods. These ad the possibility to build projections for the lattice and to build a basis for different dimensions. These features are not immediately useful here: a lattice cannot change dimension, but, for example, an random number generator may span a lattice in multiple dimensions and implementing these methods can be a good way to build them sequentially with a single object.</p>
<h2>Library features</h2>
<p>As presented above, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> revolves around solving 4 different problems. We now present what is available to resolve them with a bit more specificity. For a more hands-on approach than this section, the <a class="el" href="df/d1d/examples_page.html">Examples</a> are the place to go.</p>
<h3>Basis construction</h3>
<p><em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> can build the basis of a lattice from a set of generating vectors. That is, given a set of vectors \(\{v_1, \ldots, v_s\} \in \mathbb{Z}^t\) spanning a lattice \(L_t\), it can extract another set of vectors \(\{\hat{v}_1, \ldots, \hat{v}_t\}\) that is a basis of the lattice. There are two methods available to do just that in the <code>BasisConstruction</code> class. Beyond this functionnality, it is also possible to build a dual basis to the basis of a lattice by using that same class. In fact, <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> finds the <code>m</code>-dual to a basis. In most applications <code>m</code> will be known beforehand and can be given to the software, but this computation can also be done without a value for <code>m</code> and return the smallest fiting <code>m</code>. Most users will probably not even need to directly use these functionnalities, but <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> also has ways to build projections of a lattice, which is a much more desirable feature.</p>
<p>To build a projection what is usually done is to take a subset of the coordinates \(\{1, \ldots, t\}\) of the lattice vectors and to only consider the vectors formed by this subset of coordinates. That is, if the basis matrix is </p><p class="formulaDsp">
\[ \begin{bmatrix} v_{11} &amp; \cdots &amp; v_{1t} \\ \vdots &amp; \ddots &amp; \vdots \\ v_{t1} &amp; \cdots &amp; v_{tt} \end{bmatrix} \]
</p>
<p> the projection on coordinates \(\{i_1, \ldots, i_s\}\) is spanned by the columns of </p><p class="formulaDsp">
\[ \begin{bmatrix} v_{1i_1} &amp; \cdots &amp; v_{1i_s} \\ \vdots &amp; \ddots &amp; \vdots \\ v_{ti_1} &amp; \cdots &amp; v_{ti_s} \end{bmatrix}. \]
</p>
<p> <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> can build a basis for every such projection simply by applying one of the basis construction algorithm to the matrix above. The also is a method in <code>BasisConstruction</code> that can build this projection efficiently. To build projections, the library uses the <code>Coordinates</code> class to represent a set of indices. This class is usefull because the <code>CoordinateSets</code> namespace contains classes that can iterate over sets of coordinates specified differently. This turns out to be quite useful when building figures of merit (see <a class="el" href="df/d1d/examples_page.html#sec_FOM">Construction figures of merit</a> for an example).</p>
<p>In some cases, the construction of projections might be wanted directly when building the lattice. This occurs, for example, when building a random number generator using <code>Lacunary</code> indices (also known as leapfrog indices). This happens when a few coordinates are skipped in the output of the generator. Since building the basis for such a lattice is implementation specific, there is no algorithm to build such a basis in the library. But everything needed to build this kind of projection is included: the <code>IntLattice</code> class can be built with a set of <code>Lacunary</code> indices specified so that it will be considered when building the lattice.</p>
<h3>Reductions</h3>
<p>What we call reductions here are both lattice basis reduction algorithms and shortest vector finding algorithms. This is because all those algorithms are implemented in the same class <code>Reducer</code> and are generally employed together. There are 4 possible lattice basis reductions available:</p><ul>
<li><b>Pairwise reduction</b>, a heuristic given by Dieter in <a class="el" href="d0/de3/citelist.html#CITEREF_rDIE75a">[6]</a>. This algorithm tries to perform a Gram-Schmidt reduction by taking into account the fact that we are working with a lattice (this makes the orthogonalisation impossible most of the time).</li>
<li><b>LLL reduction</b>, a much stronger reduction given Lenstra, Lenstra and Lovasz in <a class="el" href="d0/de3/citelist.html#CITEREF_mLEN82a">[17]</a>. The idea of this reduction is to have a real condition (instead of the heuristic of pairwise reduction) on how orthogonal the reduced vectors are with their neighboor when ordered by length.</li>
<li><b>Block Korkin-Zolotarev (BKZ)</b>, a reinforcement of <b>LLL</b> reduction given by Schnorr <a class="el" href="d0/de3/citelist.html#CITEREF_mSCH91a">[23]</a>. This expands the condition of <b>LLL</b> to more than just two vectors at a time in the reduced basis.</li>
<li><b>Reduction in the sense of Minkowski</b> given by Minkowski in <a class="el" href="d0/de3/citelist.html#CITEREF_mMIN11a">[19]</a>. This reduction tries to find the successively shortest vectors while also maintaining some sort of orthogonality between them.</li>
</ul>
<p>To use any of these reductions you simply have to build an <code>IntLatticeBasis</code> object, pass it to a <code>Reducer</code> object and call the corresponding method. <a class="el" href="df/d1d/examples_page.html#sec_reduc">The Reducer class</a> example is a good starting point to learn how to use those reduction algorithms. For more information specifically on the algorithms, look at the <a class="el" href="da/d18/a_intro.html">Background</a> page.</p>
<p>Finding the shortest vector in a lattice is seldom done without preparing the lattice basis first. The algorithm used by the library to search for that vector is a Branch-and-Bound search as in <a class="el" href="d0/de3/citelist.html#CITEREF_rKNU98a">[12]</a>. This algorithm thoroughly searches for the shortest vector in the lattice and proves that the vector it found is indeed the shortest possible one. Since this algorithm takes an exponential time relatively to the lattice dimension, using one of the lattice basis reduction algorithms beforehand usually yields a much smaller Branch-and-Bound tree and a faster search. The LLL and BKZ basis reduction in particular give a basis in which the shortest vector is already a quite good approximation of the shortest vector. This reduces the space of the Branch-and-Bound search by a lot. This also means that these algorithms can be used as approximation of the full search when a large number of lattices have to be tested or when the dimension makes the Branch-and-Bound impractical.</p>
<h3>Figures of Merit</h3>
<p>Pretty much everything in <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> that is not part of what has been presented is part of the library because it simplifies the creation of figures of merit. As specified above, figures of merit can be built as a weighted sum (or minimum) of multiple measures on a lattice. If we take \(P \subset \{i \ | \ i \subseteq \{1,\ldots,t\}\}\), then a figure of merit can be built as </p><p class="formulaDsp">
\[ \sum_{p\in P} \omega_p \ell_p \text{ or } \min_{p \in P} \omega_p \ell_p. \]
</p>
<p> We do not put the emphasis on the construction of the figure of merit itself here. Doing the sum or testing for the minimum is not part of what <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> can do (because it is easy to do anyway).</p>
<p>The first feature of <em><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> when building figures of merit has already been presented: it is the construction and the iteration over sets \(P\). This is done via classes in the <code>CoordinateSets</code> namespace. The next feature the library provides is an easy way to build weights \(\omega_p\) depending on \(p\). The class <code>Weights</code> and its children implement exactly this: ways of grouping weights that depend on different properties of \(p\). It is possible to build uniform weights, weights that depend on the cardinality of \(p\), weights that differ for every \(p\) and even weights that are a product that depend on the different coordinates included in \(p\).</p>
<p>Finally, the last important feature is the inclusion of <code>Normalizer</code> and its subclasses. These classes are exactly that: normalizers for values measured on the lattice. The point of normalizers is to rescale measures between <code>0</code> and <code>1</code> so that they can be compared with each other, by taking a minimum for example. Each of those normalizers has a specific purpose and usage that is described in its documentation. Most of them are are intended to produce a bound on the length of the shortest vector in a lattice. It is then possible to divide the length obtained for the current lattice by this bound and obtain a measure between 0 and 1. This is one of the most important feature of the library as it is extensively used when performing the spectral test on congruencial random number generators. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 3 2019 17:37:01 for Lattice Tester Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
