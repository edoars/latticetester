<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Manual: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Manual
   &#160;<span id="projectnumber">unknown</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LatticeTester Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lattice namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">A classes containing multiple sets of coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a <code>std::set&lt;std::size_t&gt;</code>.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d95/classLatticeTester_1_1IntFactor.html">IntFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects of this class are the "prime" factors in the decomposition of a positive integer.  <a href="../../d6/d95/classLatticeTester_1_1IntFactor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a skeleton for the implementation of different types of lattices of arbitrary rank.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a lattice and its basis and offers tools to do basic manipulations on lattice bases.  <a href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html">Lacunary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements sets of lacunary indices.  <a href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d22/classLatticeTester_1_1LatTestWriter.html">LatTestWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the abstract class that does the writing of basic elements (<code>string</code>’s, <code>int</code>’s, <code>double</code>’s, etc.) into a file or into an <code>ostream</code>.  <a href="../../d7/d22/classLatticeTester_1_1LatTestWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db5/classLatticeTester_1_1LatTestWriterRes.html">LatTestWriterRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <code>Writer</code> abstract class to write basic elements in plain text format.  <a href="../../df/db5/classLatticeTester_1_1LatTestWriterRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html">LatticeAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class gathers other classes of <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace. ">LatticeTester</a> to create an object performing tests on lattices.  <a href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to save the configuration of a lattice test.  <a href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <em>best</em> theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in lattices.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in <em>laminated</em> lattices.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes which inherit from this base class are used in implementing bounds on the length of the shortest nonzero vector in a lattice <a class="el" href="../../d0/de3/citelist.html#CITEREF_mCON99a">[2]</a>&thinsp;.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html">NormaMinkL1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in space.  <a href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html">NormaMinkowski</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements *Minkowski*’s theoretical bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <code>Palpha</code>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <em>Rogers</em> bounds on the density of sphere packing.  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html">OrderDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order-dependent weights.  <a href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to read basic parameter fields in a configuration file.  <a href="../../da/d47/classLatticeTester_1_1ParamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de7/classLatticeTester_1_1PODWeights.html">PODWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product and order-dependent (POD) weights.  <a href="../../d4/de7/classLatticeTester_1_1PODWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3e/classLatticeTester_1_1ProductWeights.html">ProductWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product weights.  <a href="../../da/d3e/classLatticeTester_1_1ProductWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection-dependent weights.  <a href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9a/classLatticeTester_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates random numbers (in fact pseudo-random numbers).  <a href="../../dc/d9a/classLatticeTester_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a general rank 1 lattice basis.  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and to find the shortest non-zero vector of the lattice using pre-reductions and a branch-and-bound (BB) algorithm <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[13]</a>&thinsp;.  <a href="../../d8/de3/classLatticeTester_1_1Reducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db1/structLatticeTester_1_1specLatticeAnalysis.html">specLatticeAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure specializes certain members of <a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html" title="This class gathers other classes of LatticeTester to create an object performing tests on lattices...">LatticeAnalysis</a>.  <a href="../../d7/db1/structLatticeTester_1_1specLatticeAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dae/structLatticeTester_1_1specLatticeAnalysis_3_01NTL_1_1ZZ_00_01NTL_1_1vector_3_01NTL_1_1ZZ_01_4_0b314eacbca9402977ac512954ed1134d.html">specLatticeAnalysis&lt; NTL::ZZ, NTL::vector&lt; NTL::ZZ &gt;, NTL::matrix&lt; NTL::ZZ &gt;, NTL::ZZ, NTL::vector&lt; NTL::ZZ &gt;, NTL::matrix&lt; NTL::ZZ &gt;, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/structLatticeTester_1_1specLatticeAnalysis_3_01std_1_1int64__t_00_01NTL_1_1vector_3_01std_1_1int15e6eb3179468df26ae88275734203ce.html">specLatticeAnalysis&lt; std::int64_t, NTL::vector&lt; std::int64_t &gt;, NTL::matrix&lt; std::int64_t &gt;, std::int64_t, NTL::vector&lt; std::int64_t &gt;, NTL::matrix&lt; std::int64_t &gt;, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfd/structLatticeTester_1_1specReducer.html">specReducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct specializes some of the functions in a <code><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html" title="For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and ...">Reducer</a></code>.  <a href="../../d3/dfd/structLatticeTester_1_1specReducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/structLatticeTester_1_1specReducer_3_01NTL_1_1ZZ_00_01NTL_1_1ZZ_00_01NTL_1_1vector_3_01NTL_1_1ZZ1dfb05504b0bfb5c91b3d0aa703320b4.html">specReducer&lt; NTL::ZZ, NTL::ZZ, NTL::vector&lt; NTL::ZZ &gt;, NTL::matrix&lt; NTL::ZZ &gt;, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d18/structLatticeTester_1_1specReducer_3_01std_1_1int64__t_00_01std_1_1int64__t_00_01NTL_1_1vector_3fe33ef71beef4ee2dd816a5506ea1c46.html">specReducer&lt; std::int64_t, std::int64_t, NTL::vector&lt; std::int64_t &gt;, NTL::matrix&lt; std::int64_t &gt;, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html">UniformWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement the same weight for all projections.  <a href="../../d7/d89/classLatticeTester_1_1UniformWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract weights class.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a951f7e7b03767aa0971dde55f9d328ec"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a951f7e7b03767aa0971dde55f9d328ec">Weight</a></td></tr>
<tr class="memdesc:a951f7e7b03767aa0971dde55f9d328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar weight type.  <a href="#a951f7e7b03767aa0971dde55f9d328ec">More...</a><br /></td></tr>
<tr class="separator:a951f7e7b03767aa0971dde55f9d328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> { <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d">SUPNORM</a> = 1, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41">L1NORM</a> = 2, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b">L2NORM</a> = 3, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b">ZAREMBANORM</a> = 4
 }</td></tr>
<tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which norm is used to measure the length of vectors.  <a href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
<tr class="separator:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f099c800f4c648134967a45b91058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a> { <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058aff1958fbea84852b7e13d3574e4feb58">TERMINAL</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058a0c648307bf3301ea0606de04fcb79715">RES</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058a3143e7b5be2e3d8d6aad062460f51f97">TEX</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058a0f15b71adaba58b2f5476a93823f1767">GEN</a>
 }</td></tr>
<tr class="memdesc:ad78f099c800f4c648134967a45b91058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which form and where the results will be sent.  <a href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">More...</a><br /></td></tr>
<tr class="separator:ad78f099c800f4c648134967a45b91058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> { <br />
&#160;&#160;<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a3a2dae8e1fda53e4a5f9744979a818e0">QUADRUPLE</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2aa81625755ca50f79118efdc070ea6f13">EXPONENT</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a84c9ae52c66f8dd7962fd5da22a05d73">ARBITRARY</a>, 
<br />
&#160;&#160;<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2ac08082c19744a74fa9b794efe4af410a">EXACT</a>
<br />
 }</td></tr>
<tr class="memdesc:a94f96ff406f8b56147a2b7fd96209cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
 Indicates in which precision the <a class="el" href="d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> algorithms will be perfoms : <code>FP</code> &ndash; double <code>QP</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XD</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point) this is useful for large precision and magnitudes Generally speaking, the choice FP will be the fastest, but may be prone to roundoff errors and/or overflow.  <a href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">More...</a><br /></td></tr>
<tr class="separator:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64954fb374b16e1fe991e435501d65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> { <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65a5a0fef7085559362287f893caa97425e">UNKNOWN</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65a1a116a76db19a0cf4ad43973fc2c2279">PRIME</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65a4ad8925491567caca357efe9f609bb27">PROB_PRIME</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65aac48dba763e4f64c60ef238bf66f82f8">COMPOSITE</a>
 }</td></tr>
<tr class="memdesc:a9b64954fb374b16e1fe991e435501d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don’t care).  <a href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">More...</a><br /></td></tr>
<tr class="separator:a9b64954fb374b16e1fe991e435501d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> { <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0a012ebaf6929fea5b0d330cf292d19e3c">SPECTRAL</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0a91ce17e475c9002db6b12ed2e528d7e8">BEYER</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0a782750d0af36a267ddfd84b32ae7d79c">PALPHA</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0aad5231f38003aaa7c1cc16c314d9605e">BOUND_JS</a>
 }</td></tr>
<tr class="memdesc:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the merit criterion for ranking generators or lattices.  <a href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">More...</a><br /></td></tr>
<tr class="separator:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> { <br />
&#160;&#160;<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551">BESTLAT</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b">LAMINATED</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641">ROGERS</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90aa1211c0bdb2cc716a5ee478beddc44be">MINKOWSKI</a>, 
<br />
&#160;&#160;<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5">MINKL1</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a8678f06a1a0cdedc6ca0f8d28c4025c7">PALPHA_N</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a259ce031d08617531a3efa544e607d41">NORMA_GENERIC</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a332e95109d22fc84599da37006a169a5">L1</a>, 
<br />
&#160;&#160;<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90a667cae5b99c4de335199183b63c36821">L2</a>
<br />
 }</td></tr>
<tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\).  <a href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
<tr class="separator:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> { <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234">PAL</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4">NORMPAL</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c">BAL</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039">SEEKPAL</a>
 }</td></tr>
<tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
<tr class="separator:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191af830e61af769e233e1b03138520e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> { <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea9a337b68d1068c3063f764547e97db95">PreRedDieter</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520eadf669ee499af6a8e1d9a1ed06fa10275">LenstraLL</a>, 
<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea7c30bf9311d3e020a5bafa2c6ab6c4e6">NOPRERED</a>
 }</td></tr>
<tr class="memdesc:a191af830e61af769e233e1b03138520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the Prereduction Type (BKZ, LenstraLL, ...) used before applying the Branch and Bound procedure.  <a href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">More...</a><br /></td></tr>
<tr class="separator:a191af830e61af769e233e1b03138520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e5daa50d6d89fa5610dcb1c59c29036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8e5daa50d6d89fa5610dcb1c59c29036">getDir</a> (std::string dir, std::vector&lt; std::string &gt; &amp;files)</td></tr>
<tr class="separator:a8e5daa50d6d89fa5610dcb1c59c29036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822bfa7832f123a292b660daece8d35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9822bfa7832f123a292b660daece8d35">eraseExtension</a> (std::vector&lt; std::string &gt; &amp;files)</td></tr>
<tr class="separator:a9822bfa7832f123a292b660daece8d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17e1f2a8104fd33fd72f395d89ecef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#af17e1f2a8104fd33fd72f395d89ecef0">printFileNames</a> (std::vector&lt; std::string &gt; &amp;files)</td></tr>
<tr class="separator:af17e1f2a8104fd33fd72f395d89ecef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ba2e20d281e6c7ef5d3583e80a2413"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:aa3ba2e20d281e6c7ef5d3583e80a2413"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa3ba2e20d281e6c7ef5d3583e80a2413">ShortestVector</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:aa3ba2e20d281e6c7ef5d3583e80a2413"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows computation of the shortest non-zero vector in a lattice, according to the selected norm.  <a href="#aa3ba2e20d281e6c7ef5d3583e80a2413">More...</a><br /></td></tr>
<tr class="separator:aa3ba2e20d281e6c7ef5d3583e80a2413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeaba756b651dcba9aebda9634c28b6"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:a5eeaba756b651dcba9aebda9634c28b6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a5eeaba756b651dcba9aebda9634c28b6">ShortestVector</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a5eeaba756b651dcba9aebda9634c28b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB.  <a href="#a5eeaba756b651dcba9aebda9634c28b6">More...</a><br /></td></tr>
<tr class="separator:a5eeaba756b651dcba9aebda9634c28b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e63aaff56086b13da87169e30ff7eb2"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:a4e63aaff56086b13da87169e30ff7eb2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a4e63aaff56086b13da87169e30ff7eb2">FigureOfMerit</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> normalizerType, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a4e63aaff56086b13da87169e30ff7eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the Figure of Merit to a given matrix, according to a normalization criteria.  <a href="#a4e63aaff56086b13da87169e30ff7eb2">More...</a><br /></td></tr>
<tr class="separator:a4e63aaff56086b13da87169e30ff7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ce186a9eb77759a2f2957ea49d16c"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:ab56ce186a9eb77759a2f2957ea49d16c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab56ce186a9eb77759a2f2957ea49d16c">FigureOfMerit</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> normalizerType, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:ab56ce186a9eb77759a2f2957ea49d16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB.  <a href="#ab56ce186a9eb77759a2f2957ea49d16c">More...</a><br /></td></tr>
<tr class="separator:ab56ce186a9eb77759a2f2957ea49d16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ecc7b7f1d2312b4045f70a33cd1d1e"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:af4ecc7b7f1d2312b4045f70a33cd1d1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#af4ecc7b7f1d2312b4045f70a33cd1d1e">MinkowskiReduction</a> (BasIntMat &amp;matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:af4ecc7b7f1d2312b4045f70a33cd1d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reduces a basis to a Minkowski-reduced basis.  <a href="#af4ecc7b7f1d2312b4045f70a33cd1d1e">More...</a><br /></td></tr>
<tr class="separator:af4ecc7b7f1d2312b4045f70a33cd1d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afcbf893dabc0dc05f1b979c32e2a47"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:a9afcbf893dabc0dc05f1b979c32e2a47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9afcbf893dabc0dc05f1b979c32e2a47">MinkowskiReduction</a> (BasIntMat &amp;matrix, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a9afcbf893dabc0dc05f1b979c32e2a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB.  <a href="#a9afcbf893dabc0dc05f1b979c32e2a47">More...</a><br /></td></tr>
<tr class="separator:a9afcbf893dabc0dc05f1b979c32e2a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a5f5489e6e83dfa2c3d468286e69b5"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:a43a5f5489e6e83dfa2c3d468286e69b5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a43a5f5489e6e83dfa2c3d468286e69b5">FigureOfMeritBeyer</a> (BasIntMat matrix, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a43a5f5489e6e83dfa2c3d468286e69b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compute the Figure of Merit to a given matrix, according to the Beyer criteria.  <a href="#a43a5f5489e6e83dfa2c3d468286e69b5">More...</a><br /></td></tr>
<tr class="separator:a43a5f5489e6e83dfa2c3d468286e69b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602dac7b3c613c6e84d210b1fb9832c6"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </td></tr>
<tr class="memitem:a602dac7b3c613c6e84d210b1fb9832c6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a602dac7b3c613c6e84d210b1fb9832c6">FigureOfMeritBeyer</a> (BasIntMat matrix, std::int64_t maxNodesBB, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a> preRed=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> doublePrecision=<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>, double fact=0.999, int blocksize=20)</td></tr>
<tr class="memdesc:a602dac7b3c613c6e84d210b1fb9832c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing as before but with the possibility to set a different value for the variable maxNodesBB.  <a href="#a602dac7b3c613c6e84d210b1fb9832c6">More...</a><br /></td></tr>
<tr class="separator:a602dac7b3c613c6e84d210b1fb9832c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a624270d67110531f2dea4c739eff5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a61a624270d67110531f2dea4c739eff5">lFactorial</a> (int t)</td></tr>
<tr class="memdesc:a61a624270d67110531f2dea4c739eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <a href="#a61a624270d67110531f2dea4c739eff5">More...</a><br /></td></tr>
<tr class="separator:a61a624270d67110531f2dea4c739eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a886c94b54767104cea58e0f1b6c0d11e">Digamma</a> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\).  <a href="#a886c94b54767104cea58e0f1b6c0d11e">More...</a><br /></td></tr>
<tr class="separator:a886c94b54767104cea58e0f1b6c0d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e699673c28800e0563b14a05392d1c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7e699673c28800e0563b14a05392d1c0">BernoulliPoly</a> (int n, double x)</td></tr>
<tr class="memdesc:a7e699673c28800e0563b14a05392d1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <a href="#a7e699673c28800e0563b14a05392d1c0">More...</a><br /></td></tr>
<tr class="separator:a7e699673c28800e0563b14a05392d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a61a4b5013c295f9f07b9b2d8f26ee5f4">Harmonic</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n = \sum_{j=1}^n 1/j\).  <a href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">More...</a><br /></td></tr>
<tr class="separator:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum </p><p class="formulaDsp">
\[ \sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum.  <a href="#a3aefa49a034495dcc46721c275f329b0">More...</a><br /></td></tr>
<tr class="separator:a3aefa49a034495dcc46721c275f329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vJOE92b">[11]</a>) </p><p class="formulaDsp">
\[ S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}. \]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\).  <a href="#a0bb56e7569fb24800973df89d757f2fd">More...</a><br /></td></tr>
<tr class="separator:a0bb56e7569fb24800973df89d757f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes.  <a href="#ab5f708fa0e8d6aa53427b3e8927f5504">More...</a><br /></td></tr>
<tr class="separator:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5744c76f19028a3bd469d318108dd5e"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename BasIntMat &gt; </td></tr>
<tr class="memitem:ae5744c76f19028a3bd469d318108dd5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae5744c76f19028a3bd469d318108dd5e">initNorm</a> (<a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a>&lt; Int, BasIntMat &gt; &amp;config)</td></tr>
<tr class="separator:ae5744c76f19028a3bd469d318108dd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc70e568502a8240712a39087ac1aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#addc70e568502a8240712a39087ac1aca">negativeCholeski</a> ()</td></tr>
<tr class="separator:addc70e568502a8240712a39087ac1aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of <code>x</code> and <code>y</code>.  <a href="#ad4d16fed8fda92252dc423db28136932">More...</a><br /></td></tr>
<tr class="separator:ad4d16fed8fda92252dc423db28136932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42956b9be5474c04704701d5aba906cc"><td class="memTemplParams" colspan="2">template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:a42956b9be5474c04704701d5aba906cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a42956b9be5474c04704701d5aba906cc">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a42956b9be5474c04704701d5aba906cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">}.  <a href="#a42956b9be5474c04704701d5aba906cc">More...</a><br /></td></tr>
<tr class="separator:a42956b9be5474c04704701d5aba906cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf71d740b6bd3ef605406a4493939692"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:abf71d740b6bd3ef605406a4493939692"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abf71d740b6bd3ef605406a4493939692">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:abf71d740b6bd3ef605406a4493939692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#abf71d740b6bd3ef605406a4493939692">More...</a><br /></td></tr>
<tr class="separator:abf71d740b6bd3ef605406a4493939692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0f1e552bdaa65b87d6fd17c57edb040e">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <a href="#a0f1e552bdaa65b87d6fd17c57edb040e">More...</a><br /></td></tr>
<tr class="separator:a0f1e552bdaa65b87d6fd17c57edb040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8412cabdb8630ae40926d3257dddb2"><td class="memTemplParams" colspan="2">template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a8a8412cabdb8630ae40926d3257dddb2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8a8412cabdb8630ae40926d3257dddb2">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a8a8412cabdb8630ae40926d3257dddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">}.  <a href="#a8a8412cabdb8630ae40926d3257dddb2">More...</a><br /></td></tr>
<tr class="separator:a8a8412cabdb8630ae40926d3257dddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7881aa07568a3fe1bd9cc878859501ea"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7881aa07568a3fe1bd9cc878859501ea">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="separator:a7881aa07568a3fe1bd9cc878859501ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab855284bd2086dfc52a28668d339fb63"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab855284bd2086dfc52a28668d339fb63">operator&gt;&gt;</a> (istream &amp;is, <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="separator:ab855284bd2086dfc52a28668d339fb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5a20627ab18ad67cd5e99368048f67"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3e5a20627ab18ad67cd5e99368048f67">Harmonic</a> (long n)</td></tr>
<tr class="separator:a3e5a20627ab18ad67cd5e99368048f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b0c3ebff37253c6a08f8108c1edfc6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a55b0c3ebff37253c6a08f8108c1edfc6">Harmonic2</a> (long n)</td></tr>
<tr class="separator:a55b0c3ebff37253c6a08f8108c1edfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791ecbd2ea19e9fd99ee4e5e36465728"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a791ecbd2ea19e9fd99ee4e5e36465728">FourierC1</a> (double x, long n)</td></tr>
<tr class="separator:a791ecbd2ea19e9fd99ee4e5e36465728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff61b56232b701108ddaff4ac9e908b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aff61b56232b701108ddaff4ac9e908b9">FourierE1</a> (double x, long n)</td></tr>
<tr class="separator:aff61b56232b701108ddaff4ac9e908b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69303efdb0b5ca4bca51b529df28ab1"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa69303efdb0b5ca4bca51b529df28ab1">operator&gt;&gt;</a> (istream &amp;is, <a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a> &amp;weights)</td></tr>
<tr class="separator:aa69303efdb0b5ca4bca51b529df28ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad640f45482a5192afe930b746a3f7952"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad640f45482a5192afe930b746a3f7952">gcd</a> (long u, long v)</td></tr>
<tr class="separator:ad640f45482a5192afe930b746a3f7952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f873f48d9cac4fd852f1062021ac704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3f873f48d9cac4fd852f1062021ac704">SetSeed</a> (unsigned long seed)</td></tr>
<tr class="separator:a3f873f48d9cac4fd852f1062021ac704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">toString functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Useful functions for printing the <code>enum</code> constants in this module.</p>
<p>Returns the <code>enum</code> constants in this module as strings. </p>
</div></td></tr>
<tr class="memitem:a008a0f13f3dd13f786385093e6bff477"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a008a0f13f3dd13f786385093e6bff477">toStringNorm</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>)</td></tr>
<tr class="separator:a008a0f13f3dd13f786385093e6bff477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822e2af752a071d540ed96e8b5919ed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9822e2af752a071d540ed96e8b5919ed">toStringPrime</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a>)</td></tr>
<tr class="separator:a9822e2af752a071d540ed96e8b5919ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce69d86ac936dd6fc557c0dfa57a39b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7ce69d86ac936dd6fc557c0dfa57a39b">toStringCriterion</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a>)</td></tr>
<tr class="separator:a7ce69d86ac936dd6fc557c0dfa57a39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9d3e6f7b852580034df6ba3e2eed5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8ed9d3e6f7b852580034df6ba3e2eed5">toStringNorma</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>)</td></tr>
<tr class="separator:a8ed9d3e6f7b852580034df6ba3e2eed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ef31cf1e22bf8f4bba3f46bf74435f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae8ef31cf1e22bf8f4bba3f46bf74435f">toStringCalc</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a>)</td></tr>
<tr class="separator:ae8ef31cf1e22bf8f4bba3f46bf74435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58006e68111d503cf4096bf9ffc9546"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae58006e68111d503cf4096bf9ffc9546">toStringPreRed</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>)</td></tr>
<tr class="separator:ae58006e68111d503cf4096bf9ffc9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfcce9fb68f4fe2a1fd58f164ed3bbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aabfcce9fb68f4fe2a1fd58f164ed3bbf">toStringOutput</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a>)</td></tr>
<tr class="separator:aabfcce9fb68f4fe2a1fd58f164ed3bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139260fd72d3392ffac14fede81a693d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a139260fd72d3392ffac14fede81a693d">toStringPrecision</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>)</td></tr>
<tr class="separator:a139260fd72d3392ffac14fede81a693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <a href="#abba336d3a5abb22b8367ddfa37a713e4">More...</a><br /></td></tr>
<tr class="separator:abba336d3a5abb22b8367ddfa37a713e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8e829d77e42c8dbabc8f6e37eca2a714">RandInt</a> (int i, int j)</td></tr>
<tr class="memdesc:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random integer in \([i, j]\).  <a href="#a8e829d77e42c8dbabc8f6e37eca2a714">More...</a><br /></td></tr>
<tr class="separator:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a56b8827c239bd1293eacd356e5cbe3b2">RandBits</a> (int s)</td></tr>
<tr class="memdesc:a56b8827c239bd1293eacd356e5cbe3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns random blocks of \(s\) bits ( \(s\)-bit integers).  <a href="#a56b8827c239bd1293eacd356e5cbe3b2">More...</a><br /></td></tr>
<tr class="separator:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <a href="#a1a68bc6b1e81a03d09ea07fa9efed658">More...</a><br /></td></tr>
<tr class="separator:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa332228978921670954fc35afb8d7440"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa332228978921670954fc35afb8d7440">IsOdd</a> (const std::int64_t &amp;x)</td></tr>
<tr class="memdesc:aa332228978921670954fc35afb8d7440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if \(x\) is odd, and 0 otherwise.  <a href="#aa332228978921670954fc35afb8d7440">More...</a><br /></td></tr>
<tr class="separator:aa332228978921670954fc35afb8d7440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfdf172615c09b6a677ff935621632d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1cfdf172615c09b6a677ff935621632d">IsZero</a> (const std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a1cfdf172615c09b6a677ff935621632d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if \(x = 0\).  <a href="#a1cfdf172615c09b6a677ff935621632d">More...</a><br /></td></tr>
<tr class="separator:a1cfdf172615c09b6a677ff935621632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fd74c4ea41ec1c1030a621dc788845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab6fd74c4ea41ec1c1030a621dc788845">clear</a> (double &amp;x)</td></tr>
<tr class="memdesc:ab6fd74c4ea41ec1c1030a621dc788845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 0.  <a href="#ab6fd74c4ea41ec1c1030a621dc788845">More...</a><br /></td></tr>
<tr class="separator:ab6fd74c4ea41ec1c1030a621dc788845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738859ae42e8f85791ebb56705aa227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9738859ae42e8f85791ebb56705aa227">clear</a> (std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a9738859ae42e8f85791ebb56705aa227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 0.  <a href="#a9738859ae42e8f85791ebb56705aa227">More...</a><br /></td></tr>
<tr class="separator:a9738859ae42e8f85791ebb56705aa227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8196a81e178fdb095a0deaf8b0803614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8196a81e178fdb095a0deaf8b0803614">set9</a> (std::int64_t &amp;x)</td></tr>
<tr class="memdesc:a8196a81e178fdb095a0deaf8b0803614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 1.  <a href="#a8196a81e178fdb095a0deaf8b0803614">More...</a><br /></td></tr>
<tr class="separator:a8196a81e178fdb095a0deaf8b0803614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378d927159f2724975f6d1264daf8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad378d927159f2724975f6d1264daf8e4">set9</a> (NTL::ZZ &amp;x)</td></tr>
<tr class="memdesc:ad378d927159f2724975f6d1264daf8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(x\) to 1.  <a href="#ad378d927159f2724975f6d1264daf8e4">More...</a><br /></td></tr>
<tr class="separator:ad378d927159f2724975f6d1264daf8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr class="memitem:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa1b3094c46a9f69a9f1bbdcf29320886">power</a> (std::int64_t p, std::int64_t i)</td></tr>
<tr class="memdesc:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(p^i\).  <a href="#aa1b3094c46a9f69a9f1bbdcf29320886">More...</a><br /></td></tr>
<tr class="separator:aa1b3094c46a9f69a9f1bbdcf29320886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee3ffd9833b68af2a314e6b3c30641f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#afee3ffd9833b68af2a314e6b3c30641f">power2</a> (std::int64_t &amp;z, std::int64_t i)</td></tr>
<tr class="memdesc:afee3ffd9833b68af2a314e6b3c30641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(z = 2^i\).  <a href="#afee3ffd9833b68af2a314e6b3c30641f">More...</a><br /></td></tr>
<tr class="separator:afee3ffd9833b68af2a314e6b3c30641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab1dc3cf1db9f995cbf5bec7430e81393">power2</a> (NTL::ZZ &amp;z, std::int64_t i)</td></tr>
<tr class="memdesc:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets \(z = 2^i\).  <a href="#ab1dc3cf1db9f995cbf5bec7430e81393">More...</a><br /></td></tr>
<tr class="separator:ab1dc3cf1db9f995cbf5bec7430e81393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9abb8da9fdc5fa2c37d44165f8660aaf">mysqrt</a> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\).  <a href="#a9abb8da9fdc5fa2c37d44165f8660aaf">More...</a><br /></td></tr>
<tr class="separator:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f48ff79454c1d449bc309bebdcbdc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac57f48ff79454c1d449bc309bebdcbdc">SqrRoot</a> (double x)</td></tr>
<tr class="memdesc:ac57f48ff79454c1d449bc309bebdcbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\).  <a href="#ac57f48ff79454c1d449bc309bebdcbdc">More...</a><br /></td></tr>
<tr class="separator:ac57f48ff79454c1d449bc309bebdcbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae12db9335c229d7c60e570dab50ef05b">Lg</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of \(x\) in base 2.  <a href="#ae12db9335c229d7c60e570dab50ef05b">More...</a><br /></td></tr>
<tr class="separator:ae12db9335c229d7c60e570dab50ef05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a12e4b6c931cf0a19642828796b3b3bef">Lg</a> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of \(x\) in base 2.  <a href="#a12e4b6c931cf0a19642828796b3b3bef">More...</a><br /></td></tr>
<tr class="separator:a12e4b6c931cf0a19642828796b3b3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2">template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplItemLeft" align="right" valign="top">Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs</a> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <a href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">More...</a><br /></td></tr>
<tr class="separator:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1, 0 or \(-1\) depending on whether \(x&gt; 0\), \(x= 0\) or \(x&lt; 0\) respectively.  <a href="#a59016f13e4470ad17683b1cfeb70153c">More...</a><br /></td></tr>
<tr class="separator:a59016f13e4470ad17683b1cfeb70153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds to the nearest integer value.  <a href="#a15f15a1453b578cb49b2e3deda5a200d">More...</a><br /></td></tr>
<tr class="separator:a15f15a1453b578cb49b2e3deda5a200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9b920d83981962589ceb0d16d6d08"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a10b9b920d83981962589ceb0d16d6d08">Factorial</a> (int t)</td></tr>
<tr class="memdesc:a10b9b920d83981962589ceb0d16d6d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <a href="#a10b9b920d83981962589ceb0d16d6d08">More...</a><br /></td></tr>
<tr class="separator:a10b9b920d83981962589ceb0d16d6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and remainder</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>For negative operands, the <code>/</code> and <code>%</code> operators do not give the same results for <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> large integers <code>ZZ</code> and for primitive types <code>int</code> and <code>std::int64_t</code>.</p>
<p>The negative quotient differs by 1 and the remainder also differs. Thus the following small <code>inline</code> functions for division and remainder. </p><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de LatMRG en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>. </dd></dl>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(q = a/b\) by dropping the fractionnal part, i.e.  <a href="#aa9056e4da6e74d83c6061650caf9e59f">More...</a><br /></td></tr>
<tr class="separator:aa9056e4da6e74d83c6061650caf9e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c40ca56dbbbaeeae0b5ab38ac83de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa7c40ca56dbbbaeeae0b5ab38ac83de1">Quotient</a> (const NTL::ZZ &amp;a, const NTL::ZZ &amp;b, NTL::ZZ &amp;q)</td></tr>
<tr class="memdesc:aa7c40ca56dbbbaeeae0b5ab38ac83de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(q = a/b\) by dropping the fractionnal part, i.e.  <a href="#aa7c40ca56dbbbaeeae0b5ab38ac83de1">More...</a><br /></td></tr>
<tr class="separator:aa7c40ca56dbbbaeeae0b5ab38ac83de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo</a> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="separator:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fd3ae7e7a02590cc97b3f3f28e0638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab3fd3ae7e7a02590cc97b3f3f28e0638">Modulo</a> (const std::int64_t &amp;a, const std::int64_t &amp;b, std::int64_t &amp;r)</td></tr>
<tr class="memdesc:ab3fd3ae7e7a02590cc97b3f3f28e0638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the "positive" remainder \(r = a \bmod b\), i.e.  <a href="#ab3fd3ae7e7a02590cc97b3f3f28e0638">More...</a><br /></td></tr>
<tr class="separator:ab3fd3ae7e7a02590cc97b3f3f28e0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37596db3ece874abb24b32cab2873e33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a37596db3ece874abb24b32cab2873e33">Modulo</a> (const NTL::ZZ &amp;a, const NTL::ZZ &amp;b, NTL::ZZ &amp;r)</td></tr>
<tr class="memdesc:a37596db3ece874abb24b32cab2873e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the "positive" remainder \(r = a \bmod b\), i.e.  <a href="#a37596db3ece874abb24b32cab2873e33">More...</a><br /></td></tr>
<tr class="separator:a37596db3ece874abb24b32cab2873e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\).  <a href="#aeccbd231b4002cadbaac0157871f5570">More...</a><br /></td></tr>
<tr class="separator:aeccbd231b4002cadbaac0157871f5570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e86545bb8987e61e30693e09a60113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a96e86545bb8987e61e30693e09a60113">Divide</a> (std::int64_t &amp;q, std::int64_t &amp;r, const std::int64_t &amp;a, const std::int64_t &amp;b)</td></tr>
<tr class="memdesc:a96e86545bb8987e61e30693e09a60113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0.  <a href="#a96e86545bb8987e61e30693e09a60113">More...</a><br /></td></tr>
<tr class="separator:a96e86545bb8987e61e30693e09a60113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299b8335f9a690fad8b7838db6678ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab299b8335f9a690fad8b7838db6678ad">Divide</a> (NTL::ZZ &amp;q, NTL::ZZ &amp;r, const NTL::ZZ &amp;a, const NTL::ZZ &amp;b)</td></tr>
<tr class="memdesc:ab299b8335f9a690fad8b7838db6678ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0.  <a href="#ab299b8335f9a690fad8b7838db6678ad">More...</a><br /></td></tr>
<tr class="separator:ab299b8335f9a690fad8b7838db6678ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756f03c94dc21f7dbf6aad8cb6f9f4c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a756f03c94dc21f7dbf6aad8cb6f9f4c1">div</a> (std::int64_t &amp;a, const std::int64_t &amp;b, const std::int64_t &amp;d)</td></tr>
<tr class="memdesc:a756f03c94dc21f7dbf6aad8cb6f9f4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer division: \(a = b/d\).  <a href="#a756f03c94dc21f7dbf6aad8cb6f9f4c1">More...</a><br /></td></tr>
<tr class="separator:a756f03c94dc21f7dbf6aad8cb6f9f4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <a href="#a76b74332cd4ded85d51dc6020b930772">More...</a><br /></td></tr>
<tr class="separator:a76b74332cd4ded85d51dc6020b930772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a1477c8a8f0bb66d862e9ab07eccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a731a1477c8a8f0bb66d862e9ab07eccd">DivideRound</a> (const std::int64_t &amp;a, const std::int64_t &amp;b, std::int64_t &amp;q)</td></tr>
<tr class="memdesc:a731a1477c8a8f0bb66d862e9ab07eccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <a href="#a731a1477c8a8f0bb66d862e9ab07eccd">More...</a><br /></td></tr>
<tr class="separator:a731a1477c8a8f0bb66d862e9ab07eccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eec1640aff38a01eea3be0e4438522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a29eec1640aff38a01eea3be0e4438522">DivideRound</a> (const NTL::ZZ &amp;a, const NTL::ZZ &amp;b, NTL::ZZ &amp;q)</td></tr>
<tr class="memdesc:a29eec1640aff38a01eea3be0e4438522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <a href="#a29eec1640aff38a01eea3be0e4438522">More...</a><br /></td></tr>
<tr class="separator:a29eec1640aff38a01eea3be0e4438522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a14db19d396c104b730dd5ea23a7752b5">gcd</a> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\).  <a href="#a14db19d396c104b730dd5ea23a7752b5">More...</a><br /></td></tr>
<tr class="separator:a14db19d396c104b730dd5ea23a7752b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;E, Int &amp;F, Int &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For given \(a\) and \(b\), returns the values \(C\), \(D\), \(E\), \(F\) and \(G\) such that: </p><p class="formulaDsp">
\begin{align*} C a + D b &amp; = G = \mbox{GCD } (a,b) \\ E a + F b &amp; = 0. \end{align*}
</p>
<p>.  <a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">More...</a><br /></td></tr>
<tr class="separator:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2256248f03b45f7125a46a05c49b8836">CreateVect</a> (Real *&amp;A, int d)</td></tr>
<tr class="memdesc:a2256248f03b45f7125a46a05c49b8836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the vector \(A\) of dimensions \(d\) and initializes its elements to 0.  <a href="#a2256248f03b45f7125a46a05c49b8836">More...</a><br /></td></tr>
<tr class="separator:a2256248f03b45f7125a46a05c49b8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector \(A\).  <a href="#a3290d1c59f58412753021d37fd9059c3">More...</a><br /></td></tr>
<tr class="separator:a3290d1c59f58412753021d37fd9059c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a1b8b3b162c15420c29f622c74452ab5f">CreateVect</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a1b8b3b162c15420c29f622c74452ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector \(A\) of dimensions \(d+1\) and initializes its elements to 0.  <a href="#a1b8b3b162c15420c29f622c74452ab5f">More...</a><br /></td></tr>
<tr class="separator:a1b8b3b162c15420c29f622c74452ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector \(A\).  <a href="#a74b9ac2e545b1a8e3febffe458488898">More...</a><br /></td></tr>
<tr class="separator:a74b9ac2e545b1a8e3febffe458488898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a80ff1882a1a3efdc5265695e4827bda5">SetZero</a> (Real *A, int d)</td></tr>
<tr class="memdesc:a80ff1882a1a3efdc5265695e4827bda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets components \([0..d-1]\) of \(A\) to 0.  <a href="#a80ff1882a1a3efdc5265695e4827bda5">More...</a><br /></td></tr>
<tr class="separator:a80ff1882a1a3efdc5265695e4827bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a3ae135eb75ddb3c6cb8f452afc34cf18">SetZero</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets components \([0..d-1]\) of \(A\) to 0.  <a href="#a3ae135eb75ddb3c6cb8f452afc34cf18">More...</a><br /></td></tr>
<tr class="separator:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a07e941416f7b2402d15045a459e4196e">SetValue</a> (Real *A, int d, const Real &amp;x)</td></tr>
<tr class="memdesc:a07e941416f7b2402d15045a459e4196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all components \([0..d]\) of \(A\) to the value \(x\).  <a href="#a07e941416f7b2402d15045a459e4196e">More...</a><br /></td></tr>
<tr class="separator:a07e941416f7b2402d15045a459e4196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab3cd721290c62bbed850fac763aa9"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ac0ab3cd721290c62bbed850fac763aa9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac0ab3cd721290c62bbed850fac763aa9">toString</a> (const Vect &amp;A, int c, int d, const char *sep)</td></tr>
<tr class="memdesc:ac0ab3cd721290c62bbed850fac763aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([c..d-1]\) of vector \(A\) as a string.  <a href="#ac0ab3cd721290c62bbed850fac763aa9">More...</a><br /></td></tr>
<tr class="separator:ac0ab3cd721290c62bbed850fac763aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5337d95017557ef829bacfe9336d8c"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a7f5337d95017557ef829bacfe9336d8c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7f5337d95017557ef829bacfe9336d8c">toString</a> (const Vect &amp;A, int c, int d)</td></tr>
<tr class="memdesc:a7f5337d95017557ef829bacfe9336d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([c..d]\) of vector \(A\) as a string.  <a href="#a7f5337d95017557ef829bacfe9336d8c">More...</a><br /></td></tr>
<tr class="separator:a7f5337d95017557ef829bacfe9336d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0a994e5f949c8b1315d0324e7826240d">toString</a> (const Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a0a994e5f949c8b1315d0324e7826240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints components \([0..d-1]\) of vector \(A\) as a string.  <a href="#a0a994e5f949c8b1315d0324e7826240d">More...</a><br /></td></tr>
<tr class="separator:a0a994e5f949c8b1315d0324e7826240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a53d8462179e4ca773d33843c15c77afc">ProdScal</a> (const Vect1 &amp;A, const Vect2 &amp;B, int n, Scal &amp;D)</td></tr>
<tr class="memdesc:a53d8462179e4ca773d33843c15c77afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors \(A\) and \(B\), using components \([0..n-1]\), and puts the result in \(D\).  <a href="#a53d8462179e4ca773d33843c15c77afc">More...</a><br /></td></tr>
<tr class="separator:a53d8462179e4ca773d33843c15c77afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplParams" colspan="2">template&lt;typename IntVec &gt; </td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8380e2ebec791f472a3634348bc0e22a">Invert</a> (const IntVec &amp;A, IntVec &amp;B, int n)</td></tr>
<tr class="memdesc:a8380e2ebec791f472a3634348bc0e22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the polynomial \(A_0 + A_1x^1 + \cdots+ A_nx^n\) into \(x^n - A_1x^{n-1} - \cdots- A_n\).  <a href="#a8380e2ebec791f472a3634348bc0e22a">More...</a><br /></td></tr>
<tr class="separator:a8380e2ebec791f472a3634348bc0e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplParams" colspan="2">template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a7022d363aa696d09b59c9499745466a6">CalcNorm</a> (const Vect &amp;V, int n, Scal &amp;S, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a7022d363aa696d09b59c9499745466a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector \(V\), using components \([1..n]\), and puts the result in \(S\).  <a href="#a7022d363aa696d09b59c9499745466a6">More...</a><br /></td></tr>
<tr class="separator:a7022d363aa696d09b59c9499745466a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ada47b56ab96c49d7508b9379d0134472">CopyVect</a> (Vect &amp;A, const Vect &amp;B, int n)</td></tr>
<tr class="memdesc:ada47b56ab96c49d7508b9379d0134472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies vector \(B\) into vector \(A\) using components \([0..n-1]\).  <a href="#ada47b56ab96c49d7508b9379d0134472">More...</a><br /></td></tr>
<tr class="separator:ada47b56ab96c49d7508b9379d0134472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplParams" colspan="2">template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">ModifVect</a> (Vect1 &amp;A, const Vect2 &amp;B, Scal x, int n)</td></tr>
<tr class="memdesc:ad43d2de9716e712790093eff2c12631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector \(B\) multiplied by \(x\) to vector \(A\) using components \([0..n-1]\), and puts the result in \(A\).  <a href="#ad43d2de9716e712790093eff2c12631f">More...</a><br /></td></tr>
<tr class="separator:ad43d2de9716e712790093eff2c12631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a127802e517a91268330bad9930e5a5f4">ChangeSign</a> (Vect &amp;A, int n)</td></tr>
<tr class="memdesc:a127802e517a91268330bad9930e5a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign of the components \([0..n-1]\) of vector \(A\).  <a href="#a127802e517a91268330bad9930e5a5f4">More...</a><br /></td></tr>
<tr class="separator:a127802e517a91268330bad9930e5a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2df72413bf638fb96e4a4d0e078828"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#adf2df72413bf638fb96e4a4d0e078828">GCD2vect</a> (std::vector&lt; std::int64_t &gt; V, int k, int n)</td></tr>
<tr class="memdesc:adf2df72413bf638fb96e4a4d0e078828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of \(V[k],…,V[n-1]\).  <a href="#adf2df72413bf638fb96e4a4d0e078828">More...</a><br /></td></tr>
<tr class="separator:adf2df72413bf638fb96e4a4d0e078828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac21669d8af13d92327accdc26e9444ad">CreateMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:ac21669d8af13d92327accdc26e9444ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the square matrix \(A\) of dimensions \((d+1)\times(d+1)\).  <a href="#ac21669d8af13d92327accdc26e9444ad">More...</a><br /></td></tr>
<tr class="separator:ac21669d8af13d92327accdc26e9444ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a229c9368d745b9c4cae68c1b65e0e39c">DeleteMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:a229c9368d745b9c4cae68c1b65e0e39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d\times d\) matrix \(A\).  <a href="#a229c9368d745b9c4cae68c1b65e0e39c">More...</a><br /></td></tr>
<tr class="separator:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#adfafd877b46442cc4b215448f25ccd7e">CreateMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:adfafd877b46442cc4b215448f25ccd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>).  <a href="#adfafd877b46442cc4b215448f25ccd7e">More...</a><br /></td></tr>
<tr class="separator:adfafd877b46442cc4b215448f25ccd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0c884b60a0c4ee06455bf1c8e1819d35">DeleteMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix \(A\).  <a href="#a0c884b60a0c4ee06455bf1c8e1819d35">More...</a><br /></td></tr>
<tr class="separator:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a5af883014a948b37a49d69f729db70f1">CreateMatr</a> (IntMat &amp;A, int d)</td></tr>
<tr class="memdesc:a5af883014a948b37a49d69f729db70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the square matrix \(A\) of dimensions \(d\times d\) and initializes its elements to 0.  <a href="#a5af883014a948b37a49d69f729db70f1">More...</a><br /></td></tr>
<tr class="separator:a5af883014a948b37a49d69f729db70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a75474ce5f96fabf95eff6824df3d6f3d">CreateMatr</a> (IntMat &amp;A, int line, int col)</td></tr>
<tr class="memdesc:a75474ce5f96fabf95eff6824df3d6f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>).  <a href="#a75474ce5f96fabf95eff6824df3d6f3d">More...</a><br /></td></tr>
<tr class="separator:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (IntMat &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the matrix \(A\).  <a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">More...</a><br /></td></tr>
<tr class="separator:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aac81709c183b536ab80b83384314457f">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int n)</td></tr>
<tr class="memdesc:aac81709c183b536ab80b83384314457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above.  <a href="#aac81709c183b536ab80b83384314457f">More...</a><br /></td></tr>
<tr class="separator:aac81709c183b536ab80b83384314457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a8f32e22915b91e8c763f35b62c1039d9">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int line, int col)</td></tr>
<tr class="memdesc:a8f32e22915b91e8c763f35b62c1039d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above.  <a href="#a8f32e22915b91e8c763f35b62c1039d9">More...</a><br /></td></tr>
<tr class="separator:a8f32e22915b91e8c763f35b62c1039d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplParams" colspan="2">template&lt;typename MatT &gt; </td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab1f9c94abf76e8ce25eb60bb6d1bda2e">toStr</a> (const MatT &amp;mat, int d1, int d2)</td></tr>
<tr class="memdesc:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms <code>mat</code> into a string.  <a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">More...</a><br /></td></tr>
<tr class="separator:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a88ebfbbde75cc3cb82fa92f688d338c6">CheckTriangular</a> (const Matr &amp;A, int dim, const Int &amp;m)</td></tr>
<tr class="memdesc:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that square matrix \(A\) is upper triangular (modulo \(m\)) for dimensions 1 to <code>dim</code>.  <a href="#a88ebfbbde75cc3cb82fa92f688d338c6">More...</a><br /></td></tr>
<tr class="separator:a88ebfbbde75cc3cb82fa92f688d338c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#aa519a1e0589932719c79b73c76bb1093">Triangularization</a> (Matr &amp;W, Matr &amp;V, int lin, int col, const Int &amp;m)</td></tr>
<tr class="memdesc:aa519a1e0589932719c79b73c76bb1093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an integer triangularization operation modulo \(m\) on the matrix \(W\) to obtain an upper triangular matrix \(V\), dual to \(W\).  <a href="#aa519a1e0589932719c79b73c76bb1093">More...</a><br /></td></tr>
<tr class="separator:aa519a1e0589932719c79b73c76bb1093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a17df0e6fdb1f11335eaf91f82ee298b0">CalcDual</a> (const Matr &amp;A, Matr &amp;B, int d, const Int &amp;m)</td></tr>
<tr class="memdesc:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the \(m\)-dual of the matrix <code>A</code>.  <a href="#a17df0e6fdb1f11335eaf91f82ee298b0">More...</a><br /></td></tr>
<tr class="separator:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:a49105dd8e915243488440f570b3951bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a49105dd8e915243488440f570b3951bd">MyExit</a> (int status, std::string msg)</td></tr>
<tr class="memdesc:a49105dd8e915243488440f570b3951bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special exit function.  <a href="#a49105dd8e915243488440f570b3951bd">More...</a><br /></td></tr>
<tr class="separator:a49105dd8e915243488440f570b3951bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ac9adbd421a1148216c8eac1b7d96a5b8">MAX_LONG_DOUBLE</a> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\).  <a href="#ac9adbd421a1148216c8eac1b7d96a5b8">More...</a><br /></td></tr>
<tr class="separator:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540464b3215755b9a0ba65ebfba38f8"><td class="memItemLeft" align="right" valign="top">const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ae540464b3215755b9a0ba65ebfba38f8">TWO_EXP</a> []</td></tr>
<tr class="memdesc:ae540464b3215755b9a0ba65ebfba38f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\).  <a href="#ae540464b3215755b9a0ba65ebfba38f8">More...</a><br /></td></tr>
<tr class="separator:ae540464b3215755b9a0ba65ebfba38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lattice namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a951f7e7b03767aa0971dde55f9d328ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951f7e7b03767aa0971dde55f9d328ec">&#9670;&nbsp;</a></span>Weight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a951f7e7b03767aa0971dde55f9d328ec">LatticeTester::Weight</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar weight type. </p>
<dl class="section note"><dt>Note</dt><dd>We could have used <code>Weight</code>, but it might be wise to leave this <code>typedef</code> in case we decide to use <code>std::int64_t Weight</code> at some point. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&nbsp;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a> <code>PAL</code> is for the \(P_{\alpha}\) test. <br />
 <code>BAL</code> is for the bound on the \(P_{\alpha}\) test. <br />
 <code>NORMPAL</code> is for the \(P_{\alpha}\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. <br />
 <code>SEEKPAL</code> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234"></a>PAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4"></a>NORMPAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c"></a>BAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039"></a>SEEKPAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2cf3c4f4181718b7adc6f5e4513695a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3c4f4181718b7adc6f5e4513695a0">&#9670;&nbsp;</a></span>CriterionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">LatticeTester::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the merit criterion for ranking generators or lattices. </p>
<p><code>BEYER</code>: the figure of merit is the Beyer quotient \(Q_T\).<br />
 <code>SPECTRAL</code>: the figure of merit \(S_T\) is based on the spectral test.<br />
 <code>PALPHA</code>: the figure of merit is based on \(P_{\alpha}\).<br />
 <code>BOUND_JS</code>: the figure of merit is based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rSIN08a">[27]</a>&thinsp;. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0a012ebaf6929fea5b0d330cf292d19e3c"></a>SPECTRAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0a91ce17e475c9002db6b12ed2e528d7e8"></a>BEYER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0a782750d0af36a267ddfd84b32ae7d79c"></a>PALPHA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0aad5231f38003aaa7c1cc16c314d9605e"></a>BOUND_JS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&nbsp;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\). </p>
<p><code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best lattice.<br />
 <code>LAMINATED</code>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br />
 <code>ROGERS</code>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br />
 <code>MINKOWSKI</code>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br />
 <code>MINKL1</code>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br />
 <code>PALPHA_N</code>: the case of the \(P_{\alpha}\) test.<br />
 <code>NORMA_GENERIC</code>: the trivial normalization (= 1) used for the generic case when no useful normalization constant is known. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551"></a>BESTLAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b"></a>LAMINATED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641"></a>ROGERS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90aa1211c0bdb2cc716a5ee478beddc44be"></a>MINKOWSKI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5"></a>MINKL1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a8678f06a1a0cdedc6ca0f8d28c4025c7"></a>PALPHA_N&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a259ce031d08617531a3efa544e607d41"></a>NORMA_GENERIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a332e95109d22fc84599da37006a169a5"></a>L1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a667cae5b99c4de335199183b63c36821"></a>L2&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which norm is used to measure the length of vectors. </p>
<p>For \(X = (x_1,…,x_t)\),</p>
<p><code>SUPNORM</code> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br />
 <code>L1NORM</code> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br />
 <code>L2NORM</code> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br />
 <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d"></a>SUPNORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41"></a>L1NORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b"></a>L2NORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b"></a>ZAREMBANORM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad78f099c800f4c648134967a45b91058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f099c800f4c648134967a45b91058">&#9670;&nbsp;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">LatticeTester::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates in which form and where the results will be sent. </p>
<p><a class="anchor" id="REF__Const_co_output"></a> <code>TERMINAL</code>: the results will appear only on the terminal screen.<br />
 <code>RES</code>: the results will be in plain text format and sent to a file with extension <code>.res</code>.<br />
 <code>TEX</code>: the results will be in LaTeX format and sent to a file with extension <code>.tex</code>.<br />
<code>GEN</code>: the results will be sent to a file with extension <code>.gen</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058aff1958fbea84852b7e13d3574e4feb58"></a>TERMINAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a0c648307bf3301ea0606de04fcb79715"></a>RES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a3143e7b5be2e3d8d6aad062460f51f97"></a>TEX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a0f15b71adaba58b2f5476a93823f1767"></a>GEN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a94f96ff406f8b56147a2b7fd96209cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f96ff406f8b56147a2b7fd96209cb2">&#9670;&nbsp;</a></span>PrecisionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">LatticeTester::PrecisionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
 Indicates in which precision the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a> algorithms will be perfoms : <code>FP</code> &ndash; double <code>QP</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XD</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point) this is useful for large precision and magnitudes Generally speaking, the choice FP will be the fastest, but may be prone to roundoff errors and/or overflow. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6"></a>DOUBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2a3a2dae8e1fda53e4a5f9744979a818e0"></a>QUADRUPLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2aa81625755ca50f79118efdc070ea6f13"></a>EXPONENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2a84c9ae52c66f8dd7962fd5da22a05d73"></a>ARBITRARY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2ac08082c19744a74fa9b794efe4af410a"></a>EXACT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a191af830e61af769e233e1b03138520e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191af830e61af769e233e1b03138520e">&#9670;&nbsp;</a></span>PreReductionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">LatticeTester::PreReductionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the Prereduction Type (BKZ, LenstraLL, ...) used before applying the Branch and Bound procedure. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb"></a>BKZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a191af830e61af769e233e1b03138520ea9a337b68d1068c3063f764547e97db95"></a>PreRedDieter&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a191af830e61af769e233e1b03138520eadf669ee499af6a8e1d9a1ed06fa10275"></a>LenstraLL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a191af830e61af769e233e1b03138520ea7c30bf9311d3e020a5bafa2c6ab6c4e6"></a>NOPRERED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9b64954fb374b16e1fe991e435501d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b64954fb374b16e1fe991e435501d65">&#9670;&nbsp;</a></span>PrimeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">LatticeTester::PrimeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don’t care). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65a5a0fef7085559362287f893caa97425e"></a>UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65a1a116a76db19a0cf4ad43973fc2c2279"></a>PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65a4ad8925491567caca357efe9f609bb27"></a>PROB_PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65aac48dba763e4f64c60ef238bf66f82f8"></a>COMPOSITE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scal LatticeTester::abs </td>
          <td>(</td>
          <td class="paramtype">Scal&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value. </p>

</div>
</div>
<a id="a7e699673c28800e0563b14a05392d1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e699673c28800e0563b14a05392d1c0">&#9670;&nbsp;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are: </p><p class="formulaDsp">
\begin{align*} B_0(x) &amp;= 1 \\ B_1(x) &amp;= x - 1/2 \\ B_2(x) &amp;= x^2-x+1/6 \\ B_3(x) &amp;= x^3 - 3x^2/2 + x/2 \\ B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\ B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6 \\ B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42 \\ B_7(x) &amp;= x^7 - 7x^6/2 + 7x^5/2 - 7x^3/6 + x/6 \\ B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30. \end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a17df0e6fdb1f11335eaf91f82ee298b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17df0e6fdb1f11335eaf91f82ee298b0">&#9670;&nbsp;</a></span>CalcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the \(m\)-dual of the matrix <code>A</code>. </p>
<p>The result is placed in the matrix <code>B</code>. Only the first \(d\) lines and columns are considered.</p>
<p>The vectors of the basis (lines of A) need to verify the properties (i), (ii) (iii), (iv) as described in the article: R. Couture and P L'Ecuyer, Orbits and lattices for linear random number generators with composite moduli, Mathematics of Computation, Volume 65, Number 213, bottom of page 199. </p>

</div>
</div>
<a id="a7022d363aa696d09b59c9499745466a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022d363aa696d09b59c9499745466a6">&#9670;&nbsp;</a></span>CalcNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcNorm </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <code>norm</code> norm of vector \(V\), using components \([1..n]\), and puts the result in \(S\). </p>

</div>
</div>
<a id="a127802e517a91268330bad9930e5a5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127802e517a91268330bad9930e5a5f4">&#9670;&nbsp;</a></span>ChangeSign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ChangeSign </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the sign of the components \([0..n-1]\) of vector \(A\). </p>

</div>
</div>
<a id="a88ebfbbde75cc3cb82fa92f688d338c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ebfbbde75cc3cb82fa92f688d338c6">&#9670;&nbsp;</a></span>CheckTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::CheckTriangular </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that square matrix \(A\) is upper triangular (modulo \(m\)) for dimensions 1 to <code>dim</code>. </p>

</div>
</div>
<a id="ab6fd74c4ea41ec1c1030a621dc788845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fd74c4ea41ec1c1030a621dc788845">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::clear </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(x\) to 0. </p>

</div>
</div>
<a id="a9738859ae42e8f85791ebb56705aa227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9738859ae42e8f85791ebb56705aa227">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::clear </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(x\) to 0. </p>

</div>
</div>
<a id="aac81709c183b536ab80b83384314457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81709c183b536ab80b83384314457f">&#9670;&nbsp;</a></span>CopyMatr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As above. </p>
<p>Copies matrix \(B\) into matrix \(A\). </p>

</div>
</div>
<a id="a8f32e22915b91e8c763f35b62c1039d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f32e22915b91e8c763f35b62c1039d9">&#9670;&nbsp;</a></span>CopyMatr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As above. </p>

</div>
</div>
<a id="ada47b56ab96c49d7508b9379d0134472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada47b56ab96c49d7508b9379d0134472">&#9670;&nbsp;</a></span>CopyVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies vector \(B\) into vector \(A\) using components \([0..n-1]\). </p>

</div>
</div>
<a id="ac21669d8af13d92327accdc26e9444ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21669d8af13d92327accdc26e9444ad">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the square matrix \(A\) of dimensions \((d+1)\times(d+1)\). </p>
<p>Initializes its elements to 0. </p>

</div>
</div>
<a id="adfafd877b46442cc4b215448f25ccd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfafd877b46442cc4b215448f25ccd7e">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>). </p>
<p>Initializes its elements to 0. </p>

</div>
</div>
<a id="a5af883014a948b37a49d69f729db70f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af883014a948b37a49d69f729db70f1">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the square matrix \(A\) of dimensions \(d\times d\) and initializes its elements to 0. </p>

</div>
</div>
<a id="a75474ce5f96fabf95eff6824df3d6f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75474ce5f96fabf95eff6824df3d6f3d">&#9670;&nbsp;</a></span>CreateMatr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the matrix \(A\) of dimensions (<code>line</code>) \(\times\) (<code>col</code>). </p>
<p>Initializes its elements to 0. </p>

</div>
</div>
<a id="a2256248f03b45f7125a46a05c49b8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2256248f03b45f7125a46a05c49b8836">&#9670;&nbsp;</a></span>CreateVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the vector \(A\) of dimensions \(d\) and initializes its elements to 0. </p>

</div>
</div>
<a id="a1b8b3b162c15420c29f622c74452ab5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8b3b162c15420c29f622c74452ab5f">&#9670;&nbsp;</a></span>CreateVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vector \(A\) of dimensions \(d+1\) and initializes its elements to 0. </p>

</div>
</div>
<a id="a229c9368d745b9c4cae68c1b65e0e39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229c9368d745b9c4cae68c1b65e0e39c">&#9670;&nbsp;</a></span>DeleteMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the \(d\times d\) matrix \(A\). </p>

</div>
</div>
<a id="a0c884b60a0c4ee06455bf1c8e1819d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c884b60a0c4ee06455bf1c8e1819d35">&#9670;&nbsp;</a></span>DeleteMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix \(A\). </p>

</div>
</div>
<a id="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">&#9670;&nbsp;</a></span>DeleteMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the matrix \(A\). </p>

</div>
</div>
<a id="a3290d1c59f58412753021d37fd9059c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290d1c59f58412753021d37fd9059c3">&#9670;&nbsp;</a></span>DeleteVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector \(A\). </p>

</div>
</div>
<a id="a74b9ac2e545b1a8e3febffe458488898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b9ac2e545b1a8e3febffe458488898">&#9670;&nbsp;</a></span>DeleteVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector \(A\). </p>

</div>
</div>
<a id="a886c94b54767104cea58e0f1b6c0d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886c94b54767104cea58e0f1b6c0d11e">&#9670;&nbsp;</a></span>Digamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Digamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). </p>

</div>
</div>
<a id="a756f03c94dc21f7dbf6aad8cb6f9f4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756f03c94dc21f7dbf6aad8cb6f9f4c1">&#9670;&nbsp;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::div </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer division: \(a = b/d\). </p>

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&nbsp;</a></span>Divide() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\). </p>
<p>Truncates \(q\) to the nearest integer towards 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). </p>

</div>
</div>
<a id="a96e86545bb8987e61e30693e09a60113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e86545bb8987e61e30693e09a60113">&#9670;&nbsp;</a></span>Divide() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0. </p>
<p>The remainder can be negative. One always has \(a = qb + r\) and \(|r| &lt; |b|\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="ab299b8335f9a690fad8b7838db6678ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab299b8335f9a690fad8b7838db6678ad">&#9670;&nbsp;</a></span>Divide() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder \(r = a \bmod b\) by truncating \(q\) towards 0. </p>
<p>The remainder can be negative. One always has \(a = qb + r\) and \(|r| &lt; |b|\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a76b74332cd4ded85d51dc6020b930772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b74332cd4ded85d51dc6020b930772">&#9670;&nbsp;</a></span>DivideRound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>

</div>
</div>
<a id="a731a1477c8a8f0bb66d862e9ab07eccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731a1477c8a8f0bb66d862e9ab07eccd">&#9670;&nbsp;</a></span>DivideRound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>

</div>
</div>
<a id="a29eec1640aff38a01eea3be0e4438522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eec1640aff38a01eea3be0e4438522">&#9670;&nbsp;</a></span>DivideRound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>

</div>
</div>
<a id="a9822bfa7832f123a292b660daece8d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9822bfa7832f123a292b660daece8d35">&#9670;&nbsp;</a></span>eraseExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::eraseExtension </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">&#9670;&nbsp;</a></span>Euclide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For given \(a\) and \(b\), returns the values \(C\), \(D\), \(E\), \(F\) and \(G\) such that: </p><p class="formulaDsp">
\begin{align*} C a + D b &amp; = G = \mbox{GCD } (a,b) \\ E a + F b &amp; = 0. \end{align*}
</p>
<p>. </p>

</div>
</div>
<a id="a10b9b920d83981962589ceb0d16d6d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b9b920d83981962589ceb0d16d6d08">&#9670;&nbsp;</a></span>Factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::Factorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>

</div>
</div>
<a id="a4e63aaff56086b13da87169e30ff7eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e63aaff56086b13da87169e30ff7eb2">&#9670;&nbsp;</a></span>FigureOfMerit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FigureOfMerit </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>&#160;</td>
          <td class="paramname"><em>normalizerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute the Figure of Merit to a given matrix, according to a normalization criteria. </p>
<p>It first computes the shortest non-zero vector using the above functions. It then normalizes this value. Returns -1.0 if there was an error in Branch-and-Bound procedure while calculating the length of shortest non-zero vector. Return the figure of merit otherwise. </p>

</div>
</div>
<a id="ab56ce186a9eb77759a2f2957ea49d16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56ce186a9eb77759a2f2957ea49d16c">&#9670;&nbsp;</a></span>FigureOfMerit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FigureOfMerit </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>&#160;</td>
          <td class="paramname"><em>normalizerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>maxNodesBB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same thing as before but with the possibility to set a different value for the variable maxNodesBB. </p>

</div>
</div>
<a id="a43a5f5489e6e83dfa2c3d468286e69b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a5f5489e6e83dfa2c3d468286e69b5">&#9670;&nbsp;</a></span>FigureOfMeritBeyer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FigureOfMeritBeyer </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compute the Figure of Merit to a given matrix, according to the Beyer criteria. </p>
<p>It first computes the Minkowski-reduced basis of the lattice and then makes the quotient of shortest over std::int64_test vector. Returns -1.0 if there was an error in Branch-and-Bound procedure while calculating the Minkowski-reduced basis. Return the figure of merit otherwise. </p>

</div>
</div>
<a id="a602dac7b3c613c6e84d210b1fb9832c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602dac7b3c613c6e84d210b1fb9832c6">&#9670;&nbsp;</a></span>FigureOfMeritBeyer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FigureOfMeritBeyer </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>maxNodesBB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same thing as before but with the possibility to set a different value for the variable maxNodesBB. </p>

</div>
</div>
<a id="a0bb56e7569fb24800973df89d757f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb56e7569fb24800973df89d757f2fd">&#9670;&nbsp;</a></span>FourierC1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vJOE92b">[11]</a>) </p><p class="formulaDsp">
\[ S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}. \]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a791ecbd2ea19e9fd99ee4e5e36465728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791ecbd2ea19e9fd99ee4e5e36465728">&#9670;&nbsp;</a></span>FourierC1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&nbsp;</a></span>FourierE1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series </p><p class="formulaDsp">
\[ G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\; \frac{e^{2\pi i h x}}{|h|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. </p>
<p>Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="aff61b56232b701108ddaff4ac9e908b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff61b56232b701108ddaff4ac9e908b9">&#9670;&nbsp;</a></span>FourierE1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad640f45482a5192afe930b746a3f7952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad640f45482a5192afe930b746a3f7952">&#9670;&nbsp;</a></span>gcd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long LatticeTester::gcd </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14db19d396c104b730dd5ea23a7752b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db19d396c104b730dd5ea23a7752b5">&#9670;&nbsp;</a></span>gcd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::gcd </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the greatest common divisor of \(a\) and \(b\). </p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Il y a déjà des fonctions GCD dans <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module contains extensions of certain classes in NTL. ">NTL</a>, pour les <code>std::int64_t</code> et les <code>ZZ</code> (voir fichier ZZ.h) </dd></dl>

</div>
</div>
<a id="adf2df72413bf638fb96e4a4d0e078828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2df72413bf638fb96e4a4d0e078828">&#9670;&nbsp;</a></span>GCD2vect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::GCD2vect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::int64_t &gt;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of \(V[k],…,V[n-1]\). </p>

</div>
</div>
<a id="a8e5daa50d6d89fa5610dcb1c59c29036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5daa50d6d89fa5610dcb1c59c29036">&#9670;&nbsp;</a></span>getDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LatticeTester::getDir </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">&#9670;&nbsp;</a></span>Harmonic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the \(n\)-th harmonic number \(H_n = \sum_{j=1}^n 1/j\). </p>

</div>
</div>
<a id="a3e5a20627ab18ad67cd5e99368048f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5a20627ab18ad67cd5e99368048f67">&#9670;&nbsp;</a></span>Harmonic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aefa49a034495dcc46721c275f329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefa49a034495dcc46721c275f329b0">&#9670;&nbsp;</a></span>Harmonic2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum </p><p class="formulaDsp">
\[ \sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|}, \]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. </p>

</div>
</div>
<a id="a55b0c3ebff37253c6a08f8108c1edfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b0c3ebff37253c6a08f8108c1edfc6">&#9670;&nbsp;</a></span>Harmonic2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5744c76f19028a3bd469d318108dd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5744c76f19028a3bd469d318108dd5e">&#9670;&nbsp;</a></span>initNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasIntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::initNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dfd/classLatticeTester_1_1LatticeTesterConfig.html">LatticeTesterConfig</a>&lt; Int, BasIntMat &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8380e2ebec791f472a3634348bc0e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8380e2ebec791f472a3634348bc0e22a">&#9670;&nbsp;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the polynomial \(A_0 + A_1x^1 + \cdots+ A_nx^n\) into \(x^n - A_1x^{n-1} - \cdots- A_n\). </p>
<p>The result is put in \(B\). </p>

</div>
</div>
<a id="aa332228978921670954fc35afb8d7440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa332228978921670954fc35afb8d7440">&#9670;&nbsp;</a></span>IsOdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::IsOdd </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if \(x\) is odd, and 0 otherwise. </p>

</div>
</div>
<a id="a1cfdf172615c09b6a677ff935621632d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfdf172615c09b6a677ff935621632d">&#9670;&nbsp;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::IsZero </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if \(x = 0\). </p>

</div>
</div>
<a id="a61a624270d67110531f2dea4c739eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a624270d67110531f2dea4c739eff5">&#9670;&nbsp;</a></span>lFactorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::lFactorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>

</div>
</div>
<a id="ae12db9335c229d7c60e570dab50ef05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12db9335c229d7c60e570dab50ef05b">&#9670;&nbsp;</a></span>Lg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="a12e4b6c931cf0a19642828796b3b3bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e4b6c931cf0a19642828796b3b3bef">&#9670;&nbsp;</a></span>Lg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="af4ecc7b7f1d2312b4045f70a33cd1d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ecc7b7f1d2312b4045f70a33cd1d1e">&#9670;&nbsp;</a></span>MinkowskiReduction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::MinkowskiReduction </td>
          <td>(</td>
          <td class="paramtype">BasIntMat &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reduces a basis to a Minkowski-reduced basis. </p>
<p>Such basis has strong properties regarding the length of its vectors but will require a huge running time, especially when the dimension of the basis increases. Such Minkowski-reduced basis is usefull, for example, to calculate a Beyer quotient (as implemented in <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a4e63aaff56086b13da87169e30ff7eb2" title="This function compute the Figure of Merit to a given matrix, according to a normalization criteria...">FigureOfMerit()</a>). </p>

</div>
</div>
<a id="a9afcbf893dabc0dc05f1b979c32e2a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afcbf893dabc0dc05f1b979c32e2a47">&#9670;&nbsp;</a></span>MinkowskiReduction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::MinkowskiReduction </td>
          <td>(</td>
          <td class="paramtype">BasIntMat &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>maxNodesBB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same thing as before but with the possibility to set a different value for the variable maxNodesBB. </p>

</div>
</div>
<a id="ad43d2de9716e712790093eff2c12631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43d2de9716e712790093eff2c12631f">&#9670;&nbsp;</a></span>ModifVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVect </td>
          <td>(</td>
          <td class="paramtype">Vect1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds vector \(B\) multiplied by \(x\) to vector \(A\) using components \([0..n-1]\), and puts the result in \(A\). </p>

</div>
</div>
<a id="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">&#9670;&nbsp;</a></span>Modulo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3fd3ae7e7a02590cc97b3f3f28e0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fd3ae7e7a02590cc97b3f3f28e0638">&#9670;&nbsp;</a></span>Modulo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the "positive" remainder \(r = a \bmod b\), i.e. </p>
<p>such that \(0 \le r &lt; b\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="c bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="c bl br">2 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="c bl br">\(1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a37596db3ece874abb24b32cab2873e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37596db3ece874abb24b32cab2873e33">&#9670;&nbsp;</a></span>Modulo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the "positive" remainder \(r = a \bmod b\), i.e. </p>
<p>such that \(0 \le r &lt; b\). Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="c bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="c bl br">2 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="c bl br">\(1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="c bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a49105dd8e915243488440f570b3951bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49105dd8e915243488440f570b3951bd">&#9670;&nbsp;</a></span>MyExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::MyExit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special exit function. </p>
<p><code>status</code> is the status code to return to the system, <code>msg</code> is the message to print upon exit. </p>

</div>
</div>
<a id="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb8da9fdc5fa2c37d44165f8660aaf">&#9670;&nbsp;</a></span>mysqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::mysqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). </p>

</div>
</div>
<a id="addc70e568502a8240712a39087ac1aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc70e568502a8240712a39087ac1aca">&#9670;&nbsp;</a></span>negativeCholeski()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::negativeCholeski </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7881aa07568a3fe1bd9cc878859501ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7881aa07568a3fe1bd9cc878859501ea">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42956b9be5474c04704701d5aba906cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42956b9be5474c04704701d5aba906cc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, T, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>}. </p>

</div>
</div>
<a id="abf71d740b6bd3ef605406a4493939692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf71d740b6bd3ef605406a4493939692">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code></code>(first,second). </p>

</div>
</div>
<a id="a0f1e552bdaa65b87d6fd17c57edb040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1e552bdaa65b87d6fd17c57edb040e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a id="a8a8412cabdb8630ae40926d3257dddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8412cabdb8630ae40926d3257dddb2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; K, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>}. </p>

</div>
</div>
<a id="ab855284bd2086dfc52a28668d339fb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab855284bd2086dfc52a28668d339fb63">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; LatticeTester::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa69303efdb0b5ca4bca51b529df28ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69303efdb0b5ca4bca51b529df28ab1">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; LatticeTester::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1b3094c46a9f69a9f1bbdcf29320886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b3094c46a9f69a9f1bbdcf29320886">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::power </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(p^i\). </p>

</div>
</div>
<a id="afee3ffd9833b68af2a314e6b3c30641f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee3ffd9833b68af2a314e6b3c30641f">&#9670;&nbsp;</a></span>power2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::power2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(z = 2^i\). </p>

</div>
</div>
<a id="ab1dc3cf1db9f995cbf5bec7430e81393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dc3cf1db9f995cbf5bec7430e81393">&#9670;&nbsp;</a></span>power2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::power2 </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(z = 2^i\). </p>

</div>
</div>
<a id="af17e1f2a8104fd33fd72f395d89ecef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17e1f2a8104fd33fd72f395d89ecef0">&#9670;&nbsp;</a></span>printFileNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::printFileNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53d8462179e4ca773d33843c15c77afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d8462179e4ca773d33843c15c77afc">&#9670;&nbsp;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const Vect1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors \(A\) and \(B\), using components \([0..n-1]\), and puts the result in \(D\). </p>
<p>THIS DOES NOT SEEM TO BE A VERY SAFE IMPLEMENTATION </p>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&nbsp;</a></span>Quotient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(q = a/b\) by dropping the fractionnal part, i.e. </p>
<p>truncates towards 0. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="aa7c40ca56dbbbaeeae0b5ab38ac83de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c40ca56dbbbaeeae0b5ab38ac83de1">&#9670;&nbsp;</a></span>Quotient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(q = a/b\) by dropping the fractionnal part, i.e. </p>
<p>truncates towards 0. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a56b8827c239bd1293eacd356e5cbe3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b8827c239bd1293eacd356e5cbe3b2">&#9670;&nbsp;</a></span>RandBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t LatticeTester::RandBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns random blocks of \(s\) bits ( \(s\)-bit integers). </p>

</div>
</div>
<a id="a8e829d77e42c8dbabc8f6e37eca2a714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e829d77e42c8dbabc8f6e37eca2a714">&#9670;&nbsp;</a></span>RandInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random integer in \([i, j]\). </p>
<p>Numbers \(i\) and \(j\) can occur. Restriction: \(i &lt; j\). </p>

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&nbsp;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number has 53 random bits. </p>

</div>
</div>
<a id="a15f15a1453b578cb49b2e3deda5a200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f15a1453b578cb49b2e3deda5a200d">&#9670;&nbsp;</a></span>Round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::Round </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds to the nearest integer value. </p>

</div>
</div>
<a id="a8196a81e178fdb095a0deaf8b0803614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8196a81e178fdb095a0deaf8b0803614">&#9670;&nbsp;</a></span>set9() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::set9 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(x\) to 1. </p>

</div>
</div>
<a id="ad378d927159f2724975f6d1264daf8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad378d927159f2724975f6d1264daf8e4">&#9670;&nbsp;</a></span>set9() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::set9 </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets \(x\) to 1. </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&nbsp;</a></span>SetSeed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>If not called, a default seed will be used. </p>

</div>
</div>
<a id="a3f873f48d9cac4fd852f1062021ac704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f873f48d9cac4fd852f1062021ac704">&#9670;&nbsp;</a></span>SetSeed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07e941416f7b2402d15045a459e4196e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e941416f7b2402d15045a459e4196e">&#9670;&nbsp;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetValue </td>
          <td>(</td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all components \([0..d]\) of \(A\) to the value \(x\). </p>

</div>
</div>
<a id="a80ff1882a1a3efdc5265695e4827bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ff1882a1a3efdc5265695e4827bda5">&#9670;&nbsp;</a></span>SetZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets components \([0..d-1]\) of \(A\) to 0. </p>

</div>
</div>
<a id="a3ae135eb75ddb3c6cb8f452afc34cf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae135eb75ddb3c6cb8f452afc34cf18">&#9670;&nbsp;</a></span>SetZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets components \([0..d-1]\) of \(A\) to 0. </p>

</div>
</div>
<a id="aa3ba2e20d281e6c7ef5d3583e80a2413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ba2e20d281e6c7ef5d3583e80a2413">&#9670;&nbsp;</a></span>ShortestVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::ShortestVector </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows computation of the shortest non-zero vector in a lattice, according to the selected norm. </p>
<p>Many parameters can bet set by the user, otherwise the function work with default values. Returns -1.0 if there was an error in Branch-and-Bound procedure. Return the length of the shortest non-zero vector otherwise. </p>

</div>
</div>
<a id="a5eeaba756b651dcba9aebda9634c28b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeaba756b651dcba9aebda9634c28b6">&#9670;&nbsp;</a></span>ShortestVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::ShortestVector </td>
          <td>(</td>
          <td class="paramtype">BasIntMat&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>maxNodesBB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>preRed</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520ea14aace9298ad3f3297ff86c30b8d34eb">BKZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>doublePrecision</em> = <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same thing as before but with the possibility to set a different value for the variable maxNodesBB. </p>

</div>
</div>
<a id="a59016f13e4470ad17683b1cfeb70153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59016f13e4470ad17683b1cfeb70153c">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1, 0 or \(-1\) depending on whether \(x&gt; 0\), \(x= 0\) or \(x&lt; 0\) respectively. </p>

</div>
</div>
<a id="ac57f48ff79454c1d449bc309bebdcbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f48ff79454c1d449bc309bebdcbdc">&#9670;&nbsp;</a></span>SqrRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::SqrRoot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(\sqrt{x}\). </p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Cette fonction est-elle encore utilisée? </dd></dl>

</div>
</div>
<a id="ad4d16fed8fda92252dc423db28136932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d16fed8fda92252dc423db28136932">&#9670;&nbsp;</a></span>swap9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::swap9 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the values of <code>x</code> and <code>y</code>. </p>

</div>
</div>
<a id="ab1f9c94abf76e8ce25eb60bb6d1bda2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">&#9670;&nbsp;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms <code>mat</code> into a string. </p>
<p>Prints the first \(d1\) rows and \(d2\) columns. Indices start at 1. Elements with index 0 are not printed. </p>

</div>
</div>
<a id="ac0ab3cd721290c62bbed850fac763aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ab3cd721290c62bbed850fac763aa9">&#9670;&nbsp;</a></span>toString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints components \([c..d-1]\) of vector \(A\) as a string. </p>
<p>Components are separated by string <code>sep</code>. </p>

</div>
</div>
<a id="a7f5337d95017557ef829bacfe9336d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5337d95017557ef829bacfe9336d8c">&#9670;&nbsp;</a></span>toString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints components \([c..d]\) of vector \(A\) as a string. </p>

</div>
</div>
<a id="a0a994e5f949c8b1315d0324e7826240d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a994e5f949c8b1315d0324e7826240d">&#9670;&nbsp;</a></span>toString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints components \([0..d-1]\) of vector \(A\) as a string. </p>

</div>
</div>
<a id="ae8ef31cf1e22bf8f4bba3f46bf74435f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ef31cf1e22bf8f4bba3f46bf74435f">&#9670;&nbsp;</a></span>toStringCalc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringCalc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a>&#160;</td>
          <td class="paramname"><em>calc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ce69d86ac936dd6fc557c0dfa57a39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce69d86ac936dd6fc557c0dfa57a39b">&#9670;&nbsp;</a></span>toStringCriterion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringCriterion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a>&#160;</td>
          <td class="paramname"><em>criter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a008a0f13f3dd13f786385093e6bff477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008a0f13f3dd13f786385093e6bff477">&#9670;&nbsp;</a></span>toStringNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ed9d3e6f7b852580034df6ba3e2eed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed9d3e6f7b852580034df6ba3e2eed5">&#9670;&nbsp;</a></span>toStringNorma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringNorma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>&#160;</td>
          <td class="paramname"><em>norma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabfcce9fb68f4fe2a1fd58f164ed3bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfcce9fb68f4fe2a1fd58f164ed3bbf">&#9670;&nbsp;</a></span>toStringOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad78f099c800f4c648134967a45b91058">OutputType</a>&#160;</td>
          <td class="paramname"><em>sort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a139260fd72d3392ffac14fede81a693d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139260fd72d3392ffac14fede81a693d">&#9670;&nbsp;</a></span>toStringPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>precision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae58006e68111d503cf4096bf9ffc9546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58006e68111d503cf4096bf9ffc9546">&#9670;&nbsp;</a></span>toStringPreRed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringPreRed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a191af830e61af769e233e1b03138520e">PreReductionType</a>&#160;</td>
          <td class="paramname"><em>prered</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9822e2af752a071d540ed96e8b5919ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9822e2af752a071d540ed96e8b5919ed">&#9670;&nbsp;</a></span>toStringPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LatticeTester::toStringPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9b64954fb374b16e1fe991e435501d65">PrimeType</a>&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa519a1e0589932719c79b73c76bb1093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa519a1e0589932719c79b73c76bb1093">&#9670;&nbsp;</a></span>Triangularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Triangularization </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an integer triangularization operation modulo \(m\) on the matrix \(W\) to obtain an upper triangular matrix \(V\), dual to \(W\). </p>
<p>However, the matrix \(W\) will be transformed too in order to preserve duality. Only the first <code>lin</code> lines and the first <code>col</code> columns of the matrices will be considered. The main idea is to transform a generating family of vectors into a basis (removing from the family the vectors that are linear combination of other vectors).</p>
<p>Refer to the article: R. Couture and P L'Ecuyer, Orbits and lattices for linear random number generators with composite moduli, Mathematics of Computation, Volume 65, Number 213, bottom of page 199. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9adbd421a1148216c8eac1b7d96a5b8">&#9670;&nbsp;</a></span>MAX_LONG_DOUBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double LatticeTester::MAX_LONG_DOUBLE = 9007199254740992.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\). </p>

</div>
</div>
<a id="ae540464b3215755b9a0ba65ebfba38f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae540464b3215755b9a0ba65ebfba38f8">&#9670;&nbsp;</a></span>TWO_EXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::int64_t LatticeTester::TWO_EXP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,</div><div class="line">    65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216,</div><div class="line">    33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648,</div><div class="line">    4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472,</div><div class="line">    274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104,</div><div class="line">    8796093022208, 17592186044416, 35184372088832, 70368744177664,</div><div class="line">    140737488355328, 281474976710656, 562949953421312, 1125899906842624,</div><div class="line">    2251799813685248, 4503599627370496, 9007199254740992, 18014398509481984,</div><div class="line">    36028797018963968, 72057594037927936, 144115188075855872, 288230376151711744,</div><div class="line">    576460752303423488, 1152921504606846976, 2305843009213693952,</div><div class="line">    (std::int64_t)4611686018427387904U, (std::int64_t)9223372036854775808U }</div></div><!-- fragment -->
<p>Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated on Thu Jul 5 2018 14:52:03 for Lattice Tester Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
